<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wave Text – Canvas 2D (tiled only)</title>
    <link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@700;800&display=swap" rel="stylesheet" />
    <style>
      :root {
        --bg: #0e0e10;
        --fg: #f3f5f7;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: var(--fg);
      }
      .stage {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
      }
      canvas {
        width: min(92vw, 1200px);
        height: min(75vh, 720px);
        display: block;
        border-radius: 16px;
        box-shadow:
          0 20px 60px rgba(0, 0, 0, 0.45),
          0 2px 8px rgba(0, 0, 0, 0.35);
      }
      .hint {
        position: fixed;
        left: 12px;
        bottom: 12px;
        font:
          12px/1.4 system-ui,
          sans-serif;
        color: #c9cbd0;
        opacity: 0.8;
      }

      /* UI panel (fixed top-right) */
      .ui {
        position: fixed;
        top: 12px;
        right: 12px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 12px;
        padding: 12px;
        font:
          12px/1.3 system-ui,
          sans-serif;
        user-select: none;
        width: fit-content;
        max-width: 92vw;
        max-height: calc(100svh - 24px);
        overflow: auto;
      }
      .ui details {
        margin: 6px 0;
      }
      .ui summary {
        cursor: pointer;
        font-weight: 700;
        letter-spacing: 0.02em;
      }
      .grid {
        display: grid;
        grid-template-columns: auto auto;
        gap: 8px 12px;
        align-items: center;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .ui input[type="text"] {
        width: 220px;
        max-width: 65vw;
        background: transparent;
        color: var(--fg);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 8px;
        padding: 6px 8px;
      }
      .ui input[type="range"] {
        width: 220px;
        max-width: 65vw;
      }
      .ui input[type="color"] {
        inline-size: 36px;
        block-size: 22px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 0;
        background: transparent;
      }
      .val {
        opacity: 0.8;
        min-width: 64px;
        text-align: right;
        font-variant-numeric: tabular-nums;
      }
    </style>
  </head>
  <body>
    <div class="stage"><canvas id="c"></canvas></div>
    <div class="hint">Déplace la souris.</div>

    <!-- UI PANEL (tiled text only; loupe & motifs retirés) -->
    <div class="ui" id="panel">
      <details open>
        <summary>Texte</summary>
        <div class="grid">
          <label>Contenu</label>
          <div class="row"><input id="uiText" type="text" value="HOCUSBOOKUS" /></div>
          <label>Angle (°)</label>
          <div class="row">
            <input id="uiTextAngle" type="range" min="-90" max="90" step="1" value="-30" /><span
              class="val"
              id="valTextAngle"
              >-30°</span
            >
          </div>
          <label>Taille (×)</label>
          <div class="row">
            <input id="uiTextScale" type="range" min="0.5" max="2" step="0.05" value="1" /><span
              class="val"
              id="valTextScale"
              >1.00×</span
            >
          </div>
          <label>Interligne (×)</label>
          <div class="row">
            <input id="uiLineGap" type="range" min="0.8" max="2" step="0.05" value="1" /><span
              class="val"
              id="valLineGap"
              >1.00×</span
            >
          </div>
          <label>Chasse (×)</label>
          <div class="row">
            <input id="uiHSpacing" type="range" min="0.5" max="2" step="0.05" value="1" /><span
              class="val"
              id="valHSpacing"
              >1.00×</span
            >
          </div>
          <label>Esp. lettres (px)</label>
          <div class="row">
            <input id="uiLetterSpacing" type="range" min="-5" max="20" step="0.5" value="0" /><span
              class="val"
              id="valLetter"
              >0.0 px</span
            >
          </div>
          <label>Défilement (px/s)</label>
          <div class="row">
            <input id="uiScroll" type="range" min="0" max="200" step="1" value="30" /><span class="val" id="valScroll"
              >30 px/s</span
            >
          </div>
        </div>
      </details>

      <details>
        <summary>Couleurs</summary>
        <div class="grid">
          <label>Foreground</label>
          <div class="row"><input id="uiFG" type="color" value="#f3f5f7" /></div>
          <label>Background</label>
          <div class="row"><input id="uiBG" type="color" value="#0e0e10" /></div>
        </div>
      </details>

      <details>
        <summary>Physique</summary>
        <div class="grid">
          <label>Segments</label>
          <div class="row">
            <input id="uiAmount" type="range" min="8" max="150" step="1" value="24" /><span class="val" id="valAmount"
              >24</span
            >
          </div>
          <label>Fixer les bords</label>
          <div class="row"><input id="uiFixEdges" type="checkbox" /></div>
          <label>Raideur</label>
          <div class="row">
            <input id="uiStrength" type="range" min="0" max="2" step="0.01" value="0.18" /><span
              class="val"
              id="valStrength"
              >0.18</span
            >
          </div>
          <label>Masse</label>
          <div class="row">
            <input id="uiMass" type="range" min="0.5" max="5" step="0.1" value="2" /><span class="val" id="valMass"
              >2.0</span
            >
          </div>
          <label>Friction</label>
          <div class="row">
            <input id="uiFriction" type="range" min="0" max="1" step="0.01" value="0.8" /><span
              class="val"
              id="valFriction"
              >0.80</span
            >
          </div>
          <label>Rappel baseline</label>
          <div class="row">
            <input id="uiBaseline" type="range" min="0" max="0.1" step="0.001" value="0.02" /><span
              class="val"
              id="valBaseline"
              >0.020</span
            >
          </div>
          <label>Régularité</label>
          <div class="row">
            <input id="uiRegularity" type="range" min="0" max="0.5" step="0.01" value="0.15" /><span
              class="val"
              id="valRegularity"
              >0.15</span
            >
          </div>
          <label>Lissage iters</label>
          <div class="row">
            <input id="uiSmoothIters" type="range" min="0" max="5" step="1" value="2" /><span
              class="val"
              id="valSmoothIters"
              >2</span
            >
          </div>
        </div>
      </details>

      <details>
        <summary>Repos (idle)</summary>
        <div class="grid">
          <label>Activer</label>
          <div class="row"><input id="uiIdleEnabled" type="checkbox" checked /></div>
          <label>Amplitude (px)</label>
          <div class="row">
            <input id="uiIdleAmp" type="range" min="0" max="12" step="0.01" value="3" /><span
              class="val"
              id="valIdleAmp"
              >3.00 px</span
            >
          </div>
          <label>Fréquence (Hz)</label>
          <div class="row">
            <input id="uiIdleHz" type="range" min="0.001" max="0.5" step="0.001" value="0.08" /><span
              class="val"
              id="valIdleHz"
              >0.080 Hz</span
            >
          </div>
          <label>Longueur d’onde (×)</label>
          <div class="row">
            <input id="uiIdleLambda" type="range" min="0.25" max="6" step="0.01" value="1" /><span
              class="val"
              id="valIdleLambda"
              >1.00×</span
            >
          </div>
          <label>Phase (°)</label>
          <div class="row">
            <input id="uiIdlePhase" type="range" min="-180" max="180" step="1" value="0" /><span
              class="val"
              id="valIdlePhase"
              >0°</span
            >
          </div>
          <label>Reprise (s)</label>
          <div class="row">
            <input id="uiIdleResume" type="range" min="0.2" max="4" step="0.1" value="1.2" /><span
              class="val"
              id="valIdleResume"
              >1.2 s</span
            >
          </div>
        </div>
      </details>
    </div>

    <script>
      // -----------------------------
      // Utilitaire
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

      // -----------------------------
      // TextRenderer (carrelage diagonal pleine surface)
      class TextRenderer {
        constructor(getRect) {
          this.getRect = getRect;
          this.fontStack =
            "'Commissioner', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial";
        }
        measureSpaced(ctx, text, ls) {
          if (!text) return 0;
          if (!ls) return ctx.measureText(text).width;
          let w = 0;
          for (let i = 0; i < text.length; i++) {
            w += ctx.measureText(text[i]).width;
            if (i < text.length - 1) w += ls;
          }
          return w;
        }
        fillTextSpaced(ctx, text, x, y, ls) {
          if (!text) return;
          if (!ls) {
            ctx.fillText(text, x, y);
            return;
          }
          let cx = x;
          for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            ctx.fillText(ch, cx, y);
            cx += ctx.measureText(ch).width + ls;
          }
        }
        computeFontPx(rect, values) {
          return Math.max(24, Math.min(160, rect.width * 0.12)) * values.text.scale;
        }
        drawLettersWithCurrentFill(ctx, values) {
          const rect = this.getRect();
          const fontPx = this.computeFontPx(rect, values);
          ctx.textBaseline = "middle";
          ctx.textAlign = "left";
          ctx.font = `800 ${fontPx}px ${this.fontStack}`;
          // Toujours carrellé en diagonale sur tout le canvas
          const angleRad = ((values.text.angleDeg || 0) * Math.PI) / 180;
          ctx.save();
          ctx.translate(rect.width / 2, rect.height / 2);
          ctx.rotate(angleRad);
          const sample = values.text.content || "";
          const diag = Math.hypot(rect.width, rect.height);
          const stepY = fontPx * (values.text.lineGap || 1);
          const wordW = Math.max(1, this.measureSpaced(ctx, sample, values.text.letterSpacing));
          const stepX = Math.max(1, wordW * (values.text.hSpacing || 1));
          for (let row = 0, y = -diag; y <= diag; row++, y += stepY) {
            const dir = row % 2 === 0 ? 1 : -1;
            const s = values.runtime.textScrollPx % stepX;
            ctx.save();
            ctx.translate(dir * s, 0);
            const startX = -diag - stepX;
            for (let x = startX; x <= diag + stepX; x += stepX) {
              this.fillTextSpaced(ctx, values.text.content, x, y, values.text.letterSpacing);
            }
            ctx.restore();
          }
          ctx.restore();
        }
        drawFG(ctx, values) {
          ctx.fillStyle = values.colors.fg;
          this.drawLettersWithCurrentFill(ctx, values);
        }
        drawBG(ctx, values) {
          ctx.fillStyle = values.colors.bg;
          this.drawLettersWithCurrentFill(ctx, values);
        }
      }

      // -----------------------------
      // Modèle de vague (ressorts)
      class Spring {
        constructor(a, b, strength, rest) {
          this.a = a;
          this.b = b;
          this.strength = strength;
          this.restLength = rest;
          this.mamb = 1;
        }
        update(invMass) {
          const dx = this.b.x - this.a.x;
          const dyF = this.b.y - this.a.y;
          const dist = Math.hypot(dx, dyF) || 1e-6;
          const k = ((dist - this.restLength) / (dist * this.mamb)) * this.strength;
          const dy = dyF * k * invMass * 0.2;
          if (!this.a.fixed) this.a.y += dy;
          if (!this.b.fixed) this.b.y -= dy;
        }
      }
      class WaveModel {
        constructor(getRect) {
          this.getRect = getRect;
          this.points = [];
          this.springs = [];
          this.baseY = 0;
        }
        rebuild(amount, fixEdges, strength, mass) {
          const rect = this.getRect();
          this.points = [];
          this.springs = [];
          this.baseY = rect.height * 0.5;
          for (let i = 0; i <= amount; i++) {
            const x = (i / amount) * rect.width;
            const y = this.baseY;
            const px = i === 0 ? 0 : i === amount ? rect.width : x;
            const p = { x: px, y, py: y, fixed: fixEdges && (i < 2 || i > amount - 2) };
            this.points.push(p);
            if (i > 0) {
              const prev = this.points[i - 1];
              const rest = Math.hypot(p.x - prev.x, p.y - prev.y);
              const s = new Spring(prev, p, strength, rest);
              s.mamb = (1 / mass) * (1 / mass);
              this.springs.push(s);
            }
          }
        }
        step(dt, values, idleSuppress) {
          const rect = this.getRect();
          const H = rect.height;
          const baseY = this.baseY;
          const force = 1 - values.physics.friction * dt * dt;
          const invMass = 1 / values.physics.mass;
          for (let i = 0; i < this.points.length; i++) {
            const p = this.points[i];
            if (p.fixed) {
              p.py = p.y = baseY;
              continue;
            }
            const dy = (p.y - p.py) * force;
            p.py = p.y;
            p.y += dy;
            p.y += (baseY - p.y) * values.physics.baselinePull;
            const idleFactor = values.idle.enabled ? 1 - idleSuppress : 0;
            if (idleFactor > 0) {
              const phaseAcross = i / Math.max(1, this.points.length - 1);
              const phase =
                2 * Math.PI * (values.idle.lambda * phaseAcross - values.idle.hz * values.runtime.tSec) +
                (values.idle.phaseDeg * Math.PI) / 180;
              p.y += idleFactor * values.idle.amp * Math.sin(phase);
            }
            p.y = clamp(p.y, 0, H);
          }
          for (const s of this.springs) s.update(invMass);
          for (let t = 0; t < (values.physics.smoothIters | 0); t++) {
            const snap = this.points.map((p) => p.y);
            for (let i = 1; i < this.points.length - 1; i++) {
              const p = this.points[i];
              if (p.fixed) continue;
              p.y += (snap[i - 1] + snap[i + 1] - 2 * snap[i]) * values.physics.regularity;
              p.y = clamp(p.y, 0, H);
            }
          }
        }
        nudge(x, y, power) {
          const pts = this.points;
          if (pts.length < 2) return;
          const firstX = pts[0].x;
          const lastX = pts[pts.length - 1].x;
          const span = Math.max(1e-6, lastX - firstX);
          const i = Math.round(((x - firstX) / span) * (pts.length - 1));
          const infl = this.getRect().height / 4;
          const k0 = (1 / 6) * power,
            k1 = (1 / 24) * power;
          const push = (idx, k) => {
            if (idx < 0 || idx > pts.length - 1) return;
            const p = pts[idx];
            if (p.fixed) return;
            const d = Math.hypot(p.x - x, p.y - y);
            if (d < infl) p.y += (y - p.y) * k;
          };
          push(i, k0);
          push(i - 1, k1);
          push(i + 1, k1);
        }
      }

      // -----------------------------
      // Rendu de la vague + inversion du texte
      class WaveRenderer {
        constructor(getRect) {
          this.getRect = getRect;
        }
        pathFill(ctx, model) {
          const rect = this.getRect();
          const pts = model.points;
          if (pts.length < 2) return;
          ctx.beginPath();
          ctx.moveTo(0, rect.height);
          ctx.lineTo(pts[0].x, pts[0].y);
          for (let i = 0; i < pts.length - 1; i++) {
            const p0 = pts[Math.max(0, i - 1)],
              p1 = pts[i],
              p2 = pts[i + 1],
              p3 = pts[Math.min(pts.length - 1, i + 2)];
            const cp1x = p1.x + (p2.x - p0.x) / 6,
              cp1y = p1.y + (p2.y - p0.y) / 6;
            const cp2x = p2.x - (p3.x - p1.x) / 6,
              cp2y = p2.y - (p3.y - p1.y) / 6;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
          }
          ctx.lineTo(rect.width, rect.height);
          ctx.lineTo(0, rect.height);
          ctx.closePath();
        }
        renderFrame(ctxMain, off, model, textRenderer, values) {
          const rect = this.getRect();
          const { bg, fg } = values.colors;
          // fond
          ctxMain.clearRect(0, 0, rect.width, rect.height);
          ctxMain.fillStyle = bg;
          ctxMain.fillRect(0, 0, rect.width, rect.height);
          // vague (FG)
          this.pathFill(ctxMain, model);
          ctxMain.fillStyle = fg;
          ctxMain.fill();
          // texte FG
          textRenderer.drawFG(ctxMain, values);
          // inversion texte∩vague → BG via offscreen
          const { ctx: offCtx, canvas: offCanvas } = off;
          offCtx.setTransform(1, 0, 0, 1, 0, 0);
          offCtx.clearRect(0, 0, rect.width, rect.height);
          textRenderer.drawBG(offCtx, values);
          offCtx.globalCompositeOperation = "destination-in";
          this.pathFill(offCtx, model);
          offCtx.fill();
          offCtx.globalCompositeOperation = "source-over";
          ctxMain.drawImage(offCanvas, 0, 0);
        }
      }

      // -----------------------------
      // Scene (contrôleur)
      class Scene {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          this.offCanvas = document.createElement("canvas");
          this.offCtx = this.offCanvas.getContext("2d");
          this.dpr = 1;
          this.pointer = { x: 0, y: 0, hover: false };
          this.tSec = 0;
          this.idleSuppress = 0;
          this.rafId = 0;
          this.values = {
            colors: { bg: "#0e0e10", fg: "#f3f5f7" },
            physics: {
              friction: 0.8,
              mass: 2,
              strength: 0.18,
              baselinePull: 0.02,
              regularity: 0.15,
              smoothIters: 2,
              amount: 24,
              fixEdges: false,
            },
            text: {
              content: "HOCUSBOOKUS",
              tiled: true,
              angleDeg: -30,
              scale: 1,
              lineGap: 1,
              hSpacing: 1,
              letterSpacing: 0,
              scrollSpeed: 30,
            },
            idle: { enabled: true, amp: 3, hz: 0.08, lambda: 1, phaseDeg: 0, resumeSec: 1.2 },
            runtime: { textScrollPx: 0, tSec: 0 },
          };
          this.text = new TextRenderer(() => this.getRect());
          this.model = new WaveModel(() => this.getRect());
          this.renderer = new WaveRenderer(() => this.getRect());
          this._onResize = () => this.resize();
          this._onMove = (e) => this.onPointerMove(e);
          this._onLeave = () => {
            this.pointer.hover = false;
          };
          this._onEnter = () => {
            this.pointer.hover = true;
          };
        }
        getRect() {
          return this.canvas.getBoundingClientRect();
        }
        mount() {
          window.addEventListener("resize", this._onResize);
          this.canvas.addEventListener("mousemove", this._onMove, { passive: true });
          this.canvas.addEventListener("touchmove", this._onMove, { passive: true });
          this.canvas.addEventListener("mouseenter", this._onEnter);
          this.canvas.addEventListener("mouseleave", this._onLeave);
          this.canvas.addEventListener("touchstart", this._onEnter, { passive: true });
          this.canvas.addEventListener("touchend", this._onLeave, { passive: true });
          this.resize();
          this.start();
        }
        unmount() {
          this.stop();
          window.removeEventListener("resize", this._onResize);
          this.canvas.removeEventListener("mousemove", this._onMove);
          this.canvas.removeEventListener("touchmove", this._onMove);
          this.canvas.removeEventListener("mouseenter", this._onEnter);
          this.canvas.removeEventListener("mouseleave", this._onLeave);
          this.canvas.removeEventListener("touchstart", this._onEnter);
          this.canvas.removeEventListener("touchend", this._onLeave);
        }
        resize() {
          const rect = this.getRect();
          if (rect.width < 2 || rect.height < 2) return;
          this.dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
          const W = Math.floor(rect.width * this.dpr),
            H = Math.floor(rect.height * this.dpr);
          if (this.canvas.width !== W || this.canvas.height !== H) {
            this.canvas.width = W;
            this.canvas.height = H;
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.scale(this.dpr, this.dpr);
          }
          const cssW = Math.floor(rect.width),
            cssH = Math.floor(rect.height);
          if (this.offCanvas.width !== cssW || this.offCanvas.height !== cssH) {
            this.offCanvas.width = cssW;
            this.offCanvas.height = cssH;
          }
          this.offCtx.setTransform(1, 0, 0, 1, 0, 0);
          document.documentElement.style.setProperty("--bg", this.values.colors.bg);
          document.documentElement.style.setProperty("--fg", this.values.colors.fg);
          this.model.rebuild(
            this.values.physics.amount,
            this.values.physics.fixEdges,
            this.values.physics.strength,
            this.values.physics.mass,
          );
        }
        updateValues(patch) {
          const deepMerge = (t, s) => {
            for (const k in s) {
              if (s[k] && typeof s[k] === "object" && !Array.isArray(s[k])) {
                if (!t[k]) t[k] = {};
                deepMerge(t[k], s[k]);
              } else {
                t[k] = s[k];
              }
            }
            return t;
          };
          deepMerge(this.values, patch);
          this.values.physics.mass = clamp(this.values.physics.mass, 0.5, 10);
          this.values.physics.friction = clamp(this.values.physics.friction, 0, 1);
          this.values.idle.hz = clamp(this.values.idle.hz, 0, 2);
        }
        onPointerMove(e) {
          const rect = this.getRect();
          const pt = e.touches ? e.touches[0] : e;
          const x = pt.clientX - rect.left;
          const y = pt.clientY - rect.top;
          this.pointer.x = x;
          this.pointer.y = y;
          this.pointer.hover = true;
          this.model.nudge(x, y, 1.0);
          this.idleSuppress = 1;
        }
        start() {
          if (this.rafId) return;
          const loop = (now) => {
            const dt = Math.min(0.05, this._last ? (now - this._last) / 1000 : 0.016);
            this._last = now;
            this.tSec += dt;
            this.values.runtime.tSec = this.tSec;
            if (this.idleSuppress > 0) {
              this.idleSuppress = Math.max(0, this.idleSuppress - dt / Math.max(0.001, this.values.idle.resumeSec));
            }
            this.values.runtime.textScrollPx =
              (this.values.runtime.textScrollPx + this.values.text.scrollSpeed * dt) % 1e9;
            this.model.step(dt, this.values, this.idleSuppress);
            this.renderer.renderFrame(
              this.ctx,
              { ctx: this.offCtx, canvas: this.offCanvas },
              this.model,
              this.text,
              this.values,
            );
            this.rafId = requestAnimationFrame(loop);
          };
          this.rafId = requestAnimationFrame(loop);
        }
        stop() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = 0;
          }
        }
        getValues() {
          return JSON.parse(JSON.stringify(this.values));
        }
        setValues(v) {
          this.values = JSON.parse(JSON.stringify(v));
          this.resize();
        }
      }

      // Boot
      const canvas = document.getElementById("c");
      const scene = new Scene(canvas);
      scene.mount();

      // -----------------------------
      // Wire UI → scene.updateValues
      const $ = (id) => document.getElementById(id);
      const ui = {
        text: $("uiText"),
        angle: $("uiTextAngle"),
        scale: $("uiTextScale"),
        lineGap: $("uiLineGap"),
        hSpacing: $("uiHSpacing"),
        letter: $("uiLetterSpacing"),
        scroll: $("uiScroll"),
        fg: $("uiFG"),
        bg: $("uiBG"),
        amount: $("uiAmount"),
        fixEdges: $("uiFixEdges"),
        strength: $("uiStrength"),
        mass: $("uiMass"),
        friction: $("uiFriction"),
        baseline: $("uiBaseline"),
        regularity: $("uiRegularity"),
        smoothIters: $("uiSmoothIters"),
        idleEnabled: $("uiIdleEnabled"),
        idleAmp: $("uiIdleAmp"),
        idleHz: $("uiIdleHz"),
        idleLambda: $("uiIdleLambda"),
        idlePhase: $("uiIdlePhase"),
        idleResume: $("uiIdleResume"),
      };
      const val = {
        textAngle: $("valTextAngle"),
        textScale: $("valTextScale"),
        lineGap: $("valLineGap"),
        hSpacing: $("valHSpacing"),
        letter: $("valLetter"),
        scroll: $("valScroll"),
        amount: $("valAmount"),
        strength: $("valStrength"),
        mass: $("valMass"),
        friction: $("valFriction"),
        baseline: $("valBaseline"),
        regularity: $("valRegularity"),
        smoothIters: $("valSmoothIters"),
        idleAmp: $("valIdleAmp"),
        idleHz: $("valIdleHz"),
        idleLambda: $("valIdleLambda"),
        idlePhase: $("valIdlePhase"),
        idleResume: $("valIdleResume"),
      };

      // Text
      ui.text.addEventListener("input", () => scene.updateValues({ text: { content: ui.text.value } }));
      ui.angle.addEventListener("input", () => {
        val.textAngle.textContent = `${ui.angle.value}°`;
        scene.updateValues({ text: { angleDeg: parseInt(ui.angle.value, 10) } });
      });
      ui.scale.addEventListener("input", () => {
        val.textScale.textContent = `${Number(ui.scale.value).toFixed(2)}×`;
        scene.updateValues({ text: { scale: parseFloat(ui.scale.value) } });
      });
      ui.lineGap.addEventListener("input", () => {
        val.lineGap.textContent = `${Number(ui.lineGap.value).toFixed(2)}×`;
        scene.updateValues({ text: { lineGap: parseFloat(ui.lineGap.value) } });
      });
      ui.hSpacing.addEventListener("input", () => {
        val.hSpacing.textContent = `${Number(ui.hSpacing.value).toFixed(2)}×`;
        scene.updateValues({ text: { hSpacing: parseFloat(ui.hSpacing.value) } });
      });
      ui.letter.addEventListener("input", () => {
        val.letter.textContent = `${Number(ui.letter.value).toFixed(1)} px`;
        scene.updateValues({ text: { letterSpacing: parseFloat(ui.letter.value) } });
      });
      ui.scroll.addEventListener("input", () => {
        val.scroll.textContent = `${Number(ui.scroll.value).toFixed(0)} px/s`;
        scene.updateValues({ text: { scrollSpeed: parseFloat(ui.scroll.value) } });
      });

      // Colors
      ui.fg.addEventListener("input", () => {
        scene.updateValues({ colors: { fg: ui.fg.value } });
        document.documentElement.style.setProperty("--fg", ui.fg.value);
      });
      ui.bg.addEventListener("input", () => {
        scene.updateValues({ colors: { bg: ui.bg.value } });
        document.documentElement.style.setProperty("--bg", ui.bg.value);
      });

      // Physics
      ui.amount.addEventListener("input", () => {
        val.amount.textContent = ui.amount.value;
        scene.updateValues({ physics: { amount: parseInt(ui.amount.value, 10) } });
        scene.model.rebuild(
          scene.values.physics.amount,
          scene.values.physics.fixEdges,
          scene.values.physics.strength,
          scene.values.physics.mass,
        );
      });
      ui.fixEdges.addEventListener("change", () => {
        scene.updateValues({ physics: { fixEdges: ui.fixEdges.checked } });
        scene.model.rebuild(
          scene.values.physics.amount,
          scene.values.physics.fixEdges,
          scene.values.physics.strength,
          scene.values.physics.mass,
        );
      });
      ui.strength.addEventListener("input", () => {
        val.strength.textContent = Number(ui.strength.value).toFixed(2);
        scene.updateValues({ physics: { strength: parseFloat(ui.strength.value) } });
        scene.model.rebuild(
          scene.values.physics.amount,
          scene.values.physics.fixEdges,
          scene.values.physics.strength,
          scene.values.physics.mass,
        );
      });
      ui.mass.addEventListener("input", () => {
        val.mass.textContent = Number(ui.mass.value).toFixed(1);
        scene.updateValues({ physics: { mass: parseFloat(ui.mass.value) } });
        scene.model.rebuild(
          scene.values.physics.amount,
          scene.values.physics.fixEdges,
          scene.values.physics.strength,
          scene.values.physics.mass,
        );
      });
      ui.friction.addEventListener("input", () => {
        val.friction.textContent = Number(ui.friction.value).toFixed(2);
        scene.updateValues({ physics: { friction: parseFloat(ui.friction.value) } });
      });
      ui.baseline.addEventListener("input", () => {
        val.baseline.textContent = Number(ui.baseline.value).toFixed(3);
        scene.updateValues({ physics: { baselinePull: parseFloat(ui.baseline.value) } });
      });
      ui.regularity.addEventListener("input", () => {
        val.regularity.textContent = Number(ui.regularity.value).toFixed(2);
        scene.updateValues({ physics: { regularity: parseFloat(ui.regularity.value) } });
      });
      ui.smoothIters.addEventListener("input", () => {
        val.smoothIters.textContent = ui.smoothIters.value;
        scene.updateValues({ physics: { smoothIters: parseInt(ui.smoothIters.value, 10) } });
      });

      // Idle
      ui.idleEnabled.addEventListener("change", () =>
        scene.updateValues({ idle: { enabled: ui.idleEnabled.checked } }),
      );
      ui.idleAmp.addEventListener("input", () => {
        val.idleAmp.textContent = `${Number(ui.idleAmp.value).toFixed(2)} px`;
        scene.updateValues({ idle: { amp: parseFloat(ui.idleAmp.value) } });
      });
      ui.idleHz.addEventListener("input", () => {
        val.idleHz.textContent = `${Number(ui.idleHz.value).toFixed(3)} Hz`;
        scene.updateValues({ idle: { hz: parseFloat(ui.idleHz.value) } });
      });
      ui.idleLambda.addEventListener("input", () => {
        val.idleLambda.textContent = `${Number(ui.idleLambda.value).toFixed(2)}×`;
        scene.updateValues({ idle: { lambda: parseFloat(ui.idleLambda.value) } });
      });
      ui.idlePhase.addEventListener("input", () => {
        val.idlePhase.textContent = `${parseInt(ui.idlePhase.value, 10)}°`;
        scene.updateValues({ idle: { phaseDeg: parseInt(ui.idlePhase.value, 10) } });
      });
      ui.idleResume.addEventListener("input", () => {
        val.idleResume.textContent = `${Number(ui.idleResume.value).toFixed(1)} s`;
        scene.updateValues({ idle: { resumeSec: parseFloat(ui.idleResume.value) } });
      });

      // --- Sanity checks (dev-only, non bloquant)
      try {
        console.assert(scene && scene.model && Array.isArray(scene.model.points), "Scene/model non init");
      } catch (e) {
        console.warn("Sanity check:", e);
      }
    </script>
  </body>
</html>
