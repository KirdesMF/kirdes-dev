---
import { createBandPath } from "../utils/create-band-path";

type Orientation = "horizontal" | "vertical";

export interface Props {
	orientation?: Orientation;
}

const { orientation = "horizontal" } = Astro.props as Props;

const VIEWBOX_SIZE = 1000;
const LINE_COUNT = 10;
const strokeWidth = VIEWBOX_SIZE / LINE_COUNT;
const controlStart = VIEWBOX_SIZE / 3;
const controlEnd = (VIEWBOX_SIZE / 3) * 2;
const curveDepth = strokeWidth * 1.1;

const svgConfig = {
	orientation,
	strokeWidth,
	controlStart,
	controlEnd,
	curveDepth,
	lineCount: LINE_COUNT,
};

const paths = Array.from({ length: LINE_COUNT }, (_, idx) => {
	const position = strokeWidth * idx + strokeWidth / 2;
	return {
		index: idx,
		position,
		d: createBandPath({
			position,
			orientation,
			controlStart,
			controlEnd,
			viewBoxSpan: VIEWBOX_SIZE,
		}),
	};
});
---

<div data-menu class="fixed inset-0 z-50" hidden aria-hidden="true">
  <button class="absolute top-0 left-0 w-full h-full bg-transparent" data-menu-close aria-hidden="true" hidden>
    Close
  </button>
  <svg
    class="size-full"
    viewBox={`0 0 ${VIEWBOX_SIZE} ${VIEWBOX_SIZE}`}
    xmlns="http://www.w3.org/2000/svg"
    preserveAspectRatio="none"
    vector-effect="non-scaling-stroke"
    data-menu-config={JSON.stringify(svgConfig)}
  >
    {
      paths.map(({ d, index, position }) => (
        <path
          d={d}
          class="fill-none stroke-background"
          stroke-width={strokeWidth}
          stroke-linecap="round"
          data-line-index={index}
          data-target-pos={position}
        />
      ))
    }
  </svg>
</div>

<script>
  import { gsap } from "gsap";
  import { createBandPath } from "../utils/create-band-path";
  import { MENU_REQUEST_EVENT, dispatchMenuRequest, dispatchMenuState } from "../lib/menu";

  type Orientation = "horizontal" | "vertical";
  interface MenuConfig {
    orientation: Orientation;
    strokeWidth: number;
    controlStart: number;
    controlEnd: number;
    curveDepth: number;
    lineCount: number;
  }

  function parseConfig(value?: string): MenuConfig | null {
    if (!value) return null;
    try {
      return JSON.parse(value) as MenuConfig;
    } catch (error) {
      console.warn("Menu config could not be parsed", error);
      return null;
    }
  }

  const menuRoot = document.querySelector<HTMLElement>("[data-menu]");
  const svg = menuRoot?.querySelector<SVGSVGElement>("svg");
  const closeButton = menuRoot?.querySelector<HTMLButtonElement>("[data-menu-close]");

  if (!menuRoot || !svg || !closeButton) throw new Error("Menu elements not found");

  const hideMenu = () => {
    menuRoot.hidden = true;
    menuRoot.setAttribute("aria-hidden", "true");
    menuRoot.style.display = "none";
  };

  const showMenu = () => {
    menuRoot.hidden = false;
    menuRoot.removeAttribute("aria-hidden");
    menuRoot.style.display = "";
  };

  hideMenu();
  closeButton.hidden = true;
  closeButton.ariaHidden = "true";
  closeButton.disabled = true;

  const config = parseConfig(svg.dataset.menuConfig);
  if (!config) throw new Error("Menu config not found");

  const { controlStart, controlEnd, curveDepth, strokeWidth, orientation, lineCount } = config;
  const isVertical = orientation === "vertical";
  const viewBoxWidth = svg.viewBox?.baseVal?.width ?? 1000;
  const viewBoxHeight = svg.viewBox?.baseVal?.height ?? 1000;
  const viewBoxSpan = isVertical ? viewBoxHeight : viewBoxWidth;
  const axisSpan = isVertical ? viewBoxWidth : viewBoxHeight;
  const startPosition = -strokeWidth;

  const lines = Array.from(svg.querySelectorAll<SVGPathElement>("[data-line-index]")).sort(
    (a, b) => Number(b.dataset.lineIndex) - Number(a.dataset.lineIndex),
  );

  const openTimeline = gsap.timeline({ paused: true });
  lines.forEach((line, index) => {
    const targetPosition = Number(line.dataset.targetPos);

    openTimeline.fromTo(
      line,
      {
        attr: {
          d: createBandPath({
            position: startPosition,
            orientation,
            controlStart,
            controlEnd,
            viewBoxSpan,
          }),
        },
      },
      {
        attr: {
          d: createBandPath({
            position: targetPosition,
            bend: curveDepth,
            orientation,
            controlStart,
            controlEnd,
            viewBoxSpan,
          }),
        },
        duration: 0.6,
        ease: "power3.out",
      },
      index * 0.08,
    );

    openTimeline.to(
      line,
      {
        attr: {
          d: createBandPath({
            position: targetPosition,
            orientation,
            controlStart,
            controlEnd,
            viewBoxSpan,
          }),
        },
        duration: 0.9,
        ease: "elastic.out(1, 0.5)",
      },
      index * 0.08 + 0.45,
    );
  });

  const closeTimeline = gsap.timeline({ paused: true });
  lines.forEach((line, index) => {
    const targetPosition = Number(line.dataset.targetPos);
    const exitPosition = axisSpan + (lineCount - index) * strokeWidth;

    closeTimeline.to(
      line,
      {
        attr: {
          d: createBandPath({
            position: targetPosition,
            bend: curveDepth,
            orientation,
            controlStart,
            controlEnd,
            viewBoxSpan,
          }),
        },
        duration: 0.25,
        ease: "power2.inOut",
      },
      index * 0.05,
    );

    closeTimeline.to(
      line,
      {
        attr: {
          d: createBandPath({
            position: exitPosition,
            bend: curveDepth,
            orientation,
            controlStart,
            controlEnd,
            viewBoxSpan,
          }),
        },
        duration: 0.6,
        ease: "power2.in",
      },
      index * 0.05 + 0.2,
    );
  });

  const state = {
    open: false,
    animating: false,
  };

  function playOpen() {
    if (state.animating || state.open) return;
    state.animating = true;
    closeTimeline.pause(0).progress(0);
    showMenu();
    closeButton.hidden = true;
    closeButton.disabled = true;
    closeButton.ariaHidden = "true";
    openTimeline.play(0);
  }

  function playClose() {
    if (state.animating || !state.open) return;
    state.animating = true;
    closeButton.hidden = true;
    closeButton.disabled = true;
    closeButton.ariaHidden = "true";
    closeTimeline.play(0);
  }

  openTimeline.eventCallback("onComplete", () => {
    state.animating = false;
    state.open = true;
    closeButton.hidden = false;
    closeButton.disabled = false;
    closeButton.ariaHidden = "false";
    dispatchMenuState(true);
  });

  closeTimeline.eventCallback("onComplete", () => {
    state.animating = false;
    state.open = false;
    hideMenu();
    dispatchMenuState(false);
  });

  closeButton.addEventListener("click", () => {
    if (state.animating || !state.open) return;
    closeButton.disabled = true;
    dispatchMenuRequest(false);
  });

  window.addEventListener(MENU_REQUEST_EVENT, (event: Event) => {
    const detail = (event as CustomEvent<{ open: boolean }>).detail;
    if (!detail) return;
    if (detail.open) {
      playOpen();
    } else {
      playClose();
    }
  });
</script>
