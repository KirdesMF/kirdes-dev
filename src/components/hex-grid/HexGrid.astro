---
import Hexagon from "./Hexagon.astro";
import { generateHexGrid } from "./maths";
import { techStack } from "./tech-stack";

type Props = {
	hexRadius?: number;
	gap?: number;
};

const { hexRadius = 60, gap = 15 } = Astro.props;

const gridLayout = generateHexGrid(techStack.length, hexRadius, gap);

const totalSlots = gridLayout.length;
const itemsCount = techStack.length;
const emptySlotsCount = totalSlots - itemsCount;

const gridItems: ((typeof techStack)[0] | null)[] = new Array(totalSlots).fill(null);
const emptyIndices = new Set<number>();

while (emptyIndices.size < emptySlotsCount) {
	const r = Math.floor(Math.random() * (totalSlots - 1)) + 1;
	emptyIndices.add(r);
}

let techIndex = 0;
for (let i = 0; i < totalSlots; i++) {
	if (emptyIndices.has(i)) {
		gridItems[i] = null;
	} else if (techIndex < itemsCount) {
		gridItems[i] = techStack[techIndex];
		techIndex++;
	} else {
		gridItems[i] = null;
	}
}

let viewBox = "0 0 100 100";
if (gridLayout.length > 0) {
	const allX = gridLayout.map((p) => p.x);
	const allY = gridLayout.map((p) => p.y);

	const minX = Math.min(...allX) - hexRadius * 2;
	const maxX = Math.max(...allX) + hexRadius * 2;
	const minY = Math.min(...allY) - hexRadius * 2;
	const maxY = Math.max(...allY) + hexRadius * 2;

	const width = maxX - minX;
	const height = maxY - minY;

	const padding = 20;
	viewBox = `${minX - padding} ${minY - padding} ${width + padding * 2} ${height + padding * 2}`;
}

const gridCenter = (() => {
	if (gridLayout.length === 0) return { x: 0, y: 0 };
	const xs = gridLayout.map((p) => p.x);
	const ys = gridLayout.map((p) => p.y);
	return {
		x: (Math.min(...xs) + Math.max(...xs)) / 2,
		y: (Math.min(...ys) + Math.max(...ys)) / 2,
	};
})();
---

<div data-hex-grid class="w-full max-w-6xl mx-auto p-4 md:p-8">
  <div class="relative w-full aspect-4/3 md:aspect-video lg:aspect-[2.2/1]">
    <svg viewBox={viewBox} class="w-full h-full" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
      <title>Hexagon Grid</title>
      {
        gridLayout.map((pos, index) => {
          const techItem = gridItems[index];

          const dx = pos.x - gridCenter.x;
          const dy = pos.y - gridCenter.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          const staggerDelay = dist * 0.0015;

          return (
            <Hexagon x={pos.x} y={pos.y} radius={hexRadius} item={techItem} delay={staggerDelay} isEmpty={!techItem} />
          );
        })
      }
    </svg>
  </div>
</div>

<script>
  import { gsap } from "gsap";

  // `document.currentScript` is `null` for module scripts (Astro/Vite outputs ESM),
  // so find grids by selector instead of "closest()".
  const roots = Array.from(document.querySelectorAll<HTMLElement>("[data-hex-grid]"));
  for (const root of roots) {
    const hexes = Array.from(root.querySelectorAll<SVGGElement>("[data-hex-container]"));
    if (hexes.length === 0) continue;

    for (const hex of hexes) {
      const x = Number(hex.dataset.x);
      const y = Number(hex.dataset.y);
      const delay = Number(hex.dataset.delay) || 0;
      const isEmpty = hex.dataset.empty === "true";

      gsap.fromTo(
        hex,
        {
          opacity: 0,
          scale: 0.5,
          transformOrigin: `${x}px ${y}px`,
        },
        {
          opacity: isEmpty ? 0.2 : 1,
          scale: 1,
          duration: 0.8,
          delay,
          ease: "back.out(1.7)",
          force3D: true,
        },
      );

      if (isEmpty) continue;

      const content = hex.querySelector<SVGGElement>("[data-hex-content]");
      if (!content) continue;

      hex.addEventListener("mousemove", (e) => {
        const svg = content.ownerSVGElement;
        if (!svg) return;

        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svg.getScreenCTM()?.inverse());

        const dx = svgP.x - x;
        const dy = svgP.y - y;

        const strength = 0.3;
        gsap.to(content, {
          x: dx * strength,
          y: dy * strength,
          scale: 1.05,
          duration: 0.3,
          ease: "power2.out",
          overwrite: "auto",
        });
      });

      hex.addEventListener("mouseleave", () => {
        gsap.to(content, {
          x: 0,
          y: 0,
          scale: 1,
          duration: 1.2,
          ease: "elastic.out(1, 0.3)",
          overwrite: true,
        });
      });
    }
  }
</script>
