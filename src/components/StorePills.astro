---
const VIEWBOX_WIDTH = 100;
const VIEWBOX_HEIGHT = 200;
const LINE_GAP = 8;
const CURVE_OFFSET = 0;

const lines = [];
for (let y = 0; y <= VIEWBOX_HEIGHT; y += LINE_GAP) {
	lines.push(y);
}
if (lines.at(-1) !== VIEWBOX_HEIGHT) {
	lines.push(VIEWBOX_HEIGHT);
}

const KEYWORDS = ["Design", "SEO", "AI", "UX", "UI", "Web", "Mobile"];
---

<div data-box class="w-60 h-80 relative border border-dashed">
  {
    KEYWORDS.map((keyword, index) => (
      <div data-pills class="absolute px-6 py-1 origin-center border-2 rounded-full select-none">
        <p class="font-heading font-bold uppercase">{keyword}</p>
      </div>
    ))
  }
  <svg
    viewBox="0 0 100 200"
    preserveAspectRatio="none"
    vector-effect="non-scaling-stroke"
    class="size-full absolute inset-0 pointer-events-none"
  >
    <rect data-store-bg class="fill-background" x="0" y="0" width="100" height="200"></rect>
    {
      lines.map((y) => (
        <path
          data-store-path
          d={`M 0 ${y} Q ${VIEWBOX_WIDTH / 2} ${y + CURVE_OFFSET} ${VIEWBOX_WIDTH} ${y}`}
          stroke="currentColor"
          stroke-width="1"
        />
      ))
    }
  </svg>
  <div class="absolute top-0 start-0 size-2 bg-foreground -translate-1/2"></div>
  <div class="absolute top-0 end-0 size-2 bg-foreground -translate-y-1/2 translate-x-1/2"></div>
  <div class="absolute bottom-0 end-0 size-2 bg-foreground translate-y-1/2 translate-x-1/2"></div>
  <div class="absolute bottom-0 start-0 size-2 bg-foreground translate-y-1/2 -translate-x-1/2"></div>
</div>

<script>
  import { gsap } from "gsap";
  import { Engine, Render, Runner, Bodies, Composite, Mouse, MouseConstraint } from "matter-js";

  const pills = document.querySelectorAll<HTMLElement>("[data-pills]");
  const box = document.querySelector<HTMLElement>("[data-box]");

  if (!box) throw new Error("Box or Pill element not found");
  const rect = box.getBoundingClientRect();
  const engine = Engine.create();
  const render = Render.create({
    element: box,
    engine,
    options: {
      width: rect.width,
      height: rect.height,
      wireframes: false,
      background: "transparent",
      hasBounds: true,
    },
  });

  Object.assign(render.canvas.style, {
    position: "absolute",
    inset: "0",
    width: "100%",
    height: "100%",
  });

  const bodies = Array.from(pills).map((pill) => {
    const pillRect = pill.getBoundingClientRect();
    return Bodies.rectangle(Math.random() * rect.width, pillRect.height, pillRect.width, pillRect.height, {
      render: { visible: false },
    });
  });

  const boundaries = [
    // top
    Bodies.rectangle(rect.width / 2, 0, rect.width, 1, { isStatic: true, render: { visible: false } }),
    // right
    Bodies.rectangle(rect.width, rect.height / 2, 1, rect.height, { isStatic: true, render: { visible: false } }),
    // bottom
    Bodies.rectangle(rect.width / 2, rect.height, rect.width, 1, { isStatic: true, render: { visible: false } }),
    // left
    Bodies.rectangle(0, rect.height / 2, 1, rect.height, { isStatic: true, render: { visible: false } }),
  ];

  Composite.add(engine.world, [...bodies, ...boundaries]);

  const mouse = Mouse.create(render.canvas);
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: {
      stiffness: 0.2,
      render: {
        visible: false,
      },
    },
  });

  Composite.add(engine.world, mouseConstraint);
  render.mouse = mouse;

  function syncElement(element: HTMLElement | null, body: Matter.Body) {
    if (!element) return;
    element.style.transform = `translate(${body.position.x - element.offsetWidth / 2}px, ${body.position.y - element.offsetHeight / 2}px) rotate(${body.angle}rad)`;
  }

  const elements = gsap.utils.toArray<SVGAElement>(["[data-store-path]", "[data-store-bg]"]);

  engine.gravity.y = 0;
  Render.run(render);
  const runner = Runner.create();
  Runner.run(runner, engine);

  elements.forEach((path) => {
    gsap.to(path, {
      duration: 4,
      y: `-=${rect.height}`,
      ease: "power1.inOut",
      onComplete: () => {
        engine.gravity.y = 1;
      },
    });
  });

  gsap.ticker.fps(60);
  gsap.ticker.add(() => {
    pills.forEach((pill, index) => {
      syncElement(pill, bodies[index]);
    });
  });
</script>
