---
const LINES = [
	{ colStart: "col-start-1", start: { x: 0, y: 0 }, control: { x: 0, y: 50 }, end: { x: 0, y: 100 } },
	{ colStart: "col-start-4", start: { x: 0, y: 0 }, control: { x: 0, y: 50 }, end: { x: 0, y: 100 } },
	{ colStart: "col-start-7", start: { x: 0, y: 0 }, control: { x: 0, y: 50 }, end: { x: 0, y: 100 } },
	{ colStart: "col-start-10", start: { x: 0, y: 0 }, control: { x: 0, y: 50 }, end: { x: 0, y: 100 } },
	{ colStart: "col-start-12", start: { x: 100, y: 0 }, control: { x: 100, y: 50 }, end: { x: 100, y: 100 } },
];

const PATH_CONFIG = {
	strokeWidth: "0.75",
	dashArray: "5 3",
	fill: "none",
	color: "stroke-foreground/25",
};

const GRID_CLASSES = "fixed inset-0 px-32 grid grid-cols-12 gap-6";
const LAYERS = [
	{ name: "solid", className: `${GRID_CLASSES} -z-2`, dashed: false },
	{ name: "dashed", className: `${GRID_CLASSES} masked-reveal bg-background -z-2`, dashed: true },
];
---

<div data-grid-bg-container>
  {
    LAYERS.map((layer) => (
      <div class={layer.className} data-grid-layer={layer.name}>
        {LINES.map((line, index) => (
          <div
            class:list={[line.colStart, "relative"]}
            data-grid-line={index}
            data-layer={layer.name}
            data-start={`${line.start.x},${line.start.y}`}
            data-control={`${line.control.x},${line.control.y}`}
            data-end={`${line.end.x},${line.end.y}`}
          >
            <svg
              class="size-full overflow-visible"
              preserveAspectRatio="none"
              viewBox="0 0 100 100"
              fill={PATH_CONFIG.fill}
              aria-hidden="true"
            >
              <path
                data-grid-path
                d={`M${line.start.x},${line.start.y} Q${line.control.x},${line.control.y} ${line.end.x},${line.end.y}`}
                vector-effect="non-scaling-stroke"
                stroke-width={PATH_CONFIG.strokeWidth}
                stroke-dasharray={layer.dashed ? PATH_CONFIG.dashArray : undefined}
                class={PATH_CONFIG.color}
              />
            </svg>
          </div>
        ))}
      </div>
    ))
  }
</div>

<script>
  import { gsap } from "gsap";

  const config = {
    snapDistance: 4,
    releaseDistance: 100,
    duration: 1.25,
    ease: "elastic.out(1, 0.1)",
  };

  const container = document.querySelector<HTMLDivElement>("[data-grid-bg-container]");
  if (!container) throw new Error("GridBackground container not found");

  function parsePoint(value: string | undefined) {
    const [x, y] = value?.split(",").map(Number) ?? [];
    return Number.isFinite(x) && Number.isFinite(y) ? { x, y } : null;
  }

  function buildLines(root: HTMLElement) {
    return Array.from(root.querySelectorAll<HTMLElement>('[data-grid-line][data-layer="solid"]'))
      .map((solidElement) => {
        const index = Number(solidElement.dataset.gridLine ?? -1);
        const dashedElement = root.querySelector<HTMLElement>(`[data-grid-line="${index}"][data-layer="dashed"]`);

        const start = parsePoint(solidElement.dataset.start);
        const control = parsePoint(solidElement.dataset.control);
        const end = parsePoint(solidElement.dataset.end);

        if (!dashedElement || !start || !control || !end) return null;

        const solidPaths = Array.from(solidElement.querySelectorAll<SVGPathElement>("[data-grid-path]"));
        const dashedPaths = Array.from(dashedElement.querySelectorAll<SVGPathElement>("[data-grid-path]"));
        const svg = solidElement.querySelector<SVGSVGElement>("svg");

        if (!svg || !solidPaths.length || !dashedPaths.length) return null;

        return {
          start: { ...start },
          control: { ...control },
          end: { ...end },
          defaultControlX: control.x,
          solidPaths,
          dashedPaths,
          svg,
          index,
          connected: false,
        };
      })
      .filter((line): line is NonNullable<typeof line> => Boolean(line));
  }

  const lines = buildLines(container);
  let activeLine: (typeof lines)[number] | null = null;
  let needsRender = false;

  function toQuadraticPath(line: (typeof lines)[number]) {
    const { start, control, end } = line;
    return `M${start.x} ${start.y} Q${control.x} ${control.y} ${end.x} ${end.y}`;
  }

  function requestRender() {
    needsRender = true;
  }

  function updateLine(line: (typeof lines)[number]) {
    if (line.connected && Math.abs(line.control.x - line.defaultControlX) > config.releaseDistance) {
      releaseLine(line);
    }

    const d = toQuadraticPath(line);
    line.solidPaths.forEach((path) => {
      path.setAttribute("d", d);
    });
    line.dashedPaths.forEach((path) => {
      path.setAttribute("d", d);
    });
  }

  function getSVGCoordinates(svg: SVGSVGElement, event: PointerEvent) {
    const point = svg.createSVGPoint();
    point.x = event.clientX;
    point.y = event.clientY;
    return point.matrixTransform(svg.getScreenCTM()?.inverse());
  }

  function getPointOnCurve(line: (typeof lines)[number], t: number) {
    const inv = 1 - t;
    const { start, control, end } = line;
    return {
      x: inv * inv * start.x + 2 * inv * t * control.x + t * t * end.x,
      y: inv * inv * start.y + 2 * inv * t * control.y + t * t * end.y,
    };
  }

  function clamp01(value: number) {
    return Math.max(0, Math.min(1, value));
  }

  // Newton iteration over the cubic that results from d/dt(||B(t) - P||^2) = 0.
  function getClosestParameter(line: (typeof lines)[number], point: { x: number; y: number }) {
    const { start, control, end } = line;

    const ax = start.x - 2 * control.x + end.x;
    const ay = start.y - 2 * control.y + end.y;
    const bx = 2 * (control.x - start.x);
    const by = 2 * (control.y - start.y);
    const cx = start.x - point.x;
    const cy = start.y - point.y;

    const c0 = cx * bx + cy * by;
    const c1 = cx * 2 * ax + bx * bx + cy * 2 * ay + by * by;
    const c2 = 3 * ax * bx + 3 * ay * by;
    const c3 = 2 * ax * ax + 2 * ay * ay;

    let t = 0.5;
    for (let i = 0; i < 5; i++) {
      const g = ((c3 * t + c2) * t + c1) * t + c0;
      const gPrime = c1 + 2 * c2 * t + 3 * c3 * t * t;
      if (Math.abs(gPrime) < 1e-6) break;
      t = clamp01(t - g / gPrime);
    }

    return clamp01(t);
  }

  function getDistanceToLine(line: (typeof lines)[number], point: { x: number; y: number }) {
    const t = getClosestParameter(line, point);
    const candidates = [0, 1, t];
    let minDistance = Infinity;

    for (const candidate of candidates) {
      const curvePoint = getPointOnCurve(line, candidate);
      const distance = Math.hypot(point.x - curvePoint.x, point.y - curvePoint.y);
      if (distance < minDistance) minDistance = distance;
    }

    return minDistance;
  }

  function findClosestLine(event: PointerEvent) {
    let result: { line: (typeof lines)[number]; distance: number } | undefined;
    lines.forEach((line) => {
      const point = getSVGCoordinates(line.svg, event);
      const distance = getDistanceToLine(line, point);
      if (!result || distance < result.distance) {
        result = { line, distance };
      }
    });
    return result;
  }

  function connectLine(line: (typeof lines)[number]) {
    if (activeLine && activeLine !== line) releaseLine(activeLine);
    line.connected = true;
    activeLine = line;
    gsap.killTweensOf(line.control);
  }

  function releaseLine(line: (typeof lines)[number]) {
    if (!line.connected) return;
    line.connected = false;
    if (activeLine === line) activeLine = null;

    gsap.killTweensOf(line.control);
    gsap.to(line.control, {
      x: line.defaultControlX,
      duration: config.duration,
      ease: config.ease,
      onUpdate: requestRender,
    });
  }

  function onPointerMove(event: PointerEvent) {
    const closest = findClosestLine(event);
    if (closest && closest.distance <= config.snapDistance) {
      connectLine(closest.line);
    }

    if (!activeLine) return;
    const { x } = getSVGCoordinates(activeLine.svg, event);
    activeLine.control.x = x * 2 - (activeLine.start.x + activeLine.end.x) / 2;
    requestRender();
  }

  function onPointerLeave() {
    if (!activeLine) return;
    releaseLine(activeLine);
  }

  gsap.ticker.add(() => {
    if (!needsRender) return;
    needsRender = false;
    lines.forEach(updateLine);
  });

  window.addEventListener("pointermove", onPointerMove, { passive: true });
  window.addEventListener("pointerleave", onPointerLeave);
  window.addEventListener("pointercancel", onPointerLeave);

  requestRender();
</script>
