---
interface Props {
  frequency?: number;
  amplitude?: number;
  speed?: number;
  rotation?: number;
  class?: string;
}

const { frequency = 0.5, amplitude = 60, speed = 0.1, rotation = 45, class: className } = Astro.props;
---

<div 
  class:list={["portfolio-tissue-container w-full h-full overflow-hidden relative", className]}
  data-frequency={frequency}
  data-amplitude={amplitude}
  data-speed={speed}
  data-rotation={rotation}
>
  {import.meta.env.DEV && (
    <div class="absolute top-4 right-4 z-50 bg-white/80 p-4 rounded shadow-lg backdrop-blur-sm w-64">
      <h3 class="text-sm font-bold mb-3 text-black">Dev Controls</h3>
      <div class="flex flex-col gap-3">
        <label class="text-xs text-black flex flex-col gap-1">
          <div class="flex justify-between">
            <span>Frequency</span>
            <span id="freq-val">{frequency}</span>
          </div>
          <input type="range" id="freq-slider" min="0.1" max="2.0" step="0.1" value={frequency} class="w-full" />
        </label>
        <label class="text-xs text-black flex flex-col gap-1">
          <div class="flex justify-between">
            <span>Amplitude</span>
            <span id="amp-val">{amplitude}</span>
          </div>
          <input type="range" id="amp-slider" min="0" max="300" step="1" value={amplitude} class="w-full" />
        </label>
        <label class="text-xs text-black flex flex-col gap-1">
          <div class="flex justify-between">
            <span>Speed</span>
            <span id="speed-val">{speed}</span>
          </div>
          <input type="range" id="speed-slider" min="0" max="0.5" step="0.01" value={speed} class="w-full" />
        </label>
        <label class="text-xs text-black flex flex-col gap-1">
          <div class="flex justify-between">
            <span>Rotation</span>
            <span id="rot-val">{rotation}</span>
          </div>
          <input type="range" id="rot-slider" min="0" max="360" step="1" value={rotation} class="w-full" />
        </label>
      </div>
    </div>
  )}
</div>

<script>
  import { Application,  Text,  TilingSprite, Mesh, PlaneGeometry, Rectangle, TextStyle } from 'pixi.js';
  import { onThemeChange } from '../core/theme-events';
  import { convertCssColorToRgbFloat, rgbFloatToHex } from '../utils/colors';

  class PortfolioTissue {
    private app: Application;
    private container: HTMLElement;
    private plane: Mesh | null = null;
    private text: Text | null = null;
    private tilingSprite: TilingSprite | null = null;
    private time: number = 0;
    private unsubscribeTheme: (() => void) | null = null;
    
    // Configuration
    public frequency: number;
    public amplitude: number;
    public speed: number;
    public rotation: number;
    private originalPositions: Float32Array | null = null;

    constructor(container: HTMLElement) {
      this.container = container;
      this.frequency = parseFloat(container.dataset.frequency || '0.5');
      this.amplitude = parseFloat(container.dataset.amplitude || '60');
      this.speed = parseFloat(container.dataset.speed || '0.1');
      this.rotation = parseFloat(container.dataset.rotation || '45');
      
      this.app = new Application();
      this.init();
    }

    async init() {
      await this.app.init({
        resizeTo: this.container,
        backgroundAlpha: 0, // Transparent background
        antialias: true,
        autoDensity: true,
        resolution: window.devicePixelRatio || 1,
      });

      this.container.appendChild(this.app.canvas);

      // Create the text texture
      const textStyle = new TextStyle({
        fontFamily: 'Arial Black, Arial, sans-serif',
        fontSize: 80, // Larger text
        fontWeight: '900',
        fill: this.getColor(), // Initial color
        align: 'center',
      });

      this.text = new Text({ text: 'PORTFOLIO ', style: textStyle }); // Reduced spaces
      
      // Generate texture from text
      const textTexture = this.app.renderer.generateTexture(this.text);
      
      // Add padding to cover wave displacement at edges
      const padding = 100;
      const width = this.app.screen.width + padding * 2;
      const height = this.app.screen.height + padding * 2;
      
      this.tilingSprite = new TilingSprite({
        texture: textTexture,
        width: width,
        height: height,
      });
      
      // Rotate the pattern
      this.tilingSprite.tileRotation = -Math.PI / 4;
      this.tilingSprite.tileScale.set(0.8); // Adjust scale if needed
      
      // Render the tiling sprite to a texture
      const renderTexture = this.app.renderer.generateTexture({
        target: this.tilingSprite,
        resolution: 1,
        frame: new Rectangle(0, 0, width, height)
      });
      
      // Create the plane using Mesh and PlaneGeometry
      const geometry = new PlaneGeometry({
        width: width,
        height: height,
        verticesX: 60, // More vertices for smoother wave
        verticesY: 60
      });
      
      this.plane = new Mesh({
        geometry: geometry,
        texture: renderTexture
      });

      // Offset the plane to center the larger area
      this.plane.position.set(-padding, -padding);

      if (this.plane) {
        this.app.stage.addChild(this.plane);
      }
      
      this.app.ticker.add((ticker) => {
        this.update(ticker.deltaTime);
      });

      // Listen for theme changes
      this.unsubscribeTheme = onThemeChange(() => {
        this.updateColor();
      });
    }

    getColor(): number {
      // Get the color from CSS variable
      const style = getComputedStyle(document.documentElement);
      const colorStr = style.getPropertyValue('--color-foreground').trim();
      
      // Convert CSS color string (potentially oklch) to PixiJS hex
      try {
        const rgb = convertCssColorToRgbFloat(colorStr || '#000000');
        return rgbFloatToHex(rgb);
      } catch (e) {
        console.error('Failed to parse color:', colorStr, e);
        return 0x000000;
      }
    }

    async updateColor() {
      if (!this.text || !this.tilingSprite || !this.plane || !this.app.renderer) return;

      const newColor = this.getColor();
      this.text.style.fill = newColor;
      
      // Regenerate textures
      // Note: In a production app we should carefully manage texture memory (destroy old ones)
      
      const oldTextTexture = this.tilingSprite.texture;
      const newTextTexture = this.app.renderer.generateTexture(this.text);
      this.tilingSprite.texture = newTextTexture;
      
      // We need to re-render the tiling sprite to a new texture for the mesh
      const width = this.tilingSprite.width;
      const height = this.tilingSprite.height;
      
      const oldRenderTexture = this.plane.texture;
      const newRenderTexture = this.app.renderer.generateTexture({
        target: this.tilingSprite,
        resolution: 1,
        frame: new Rectangle(0, 0, width, height)
      });
      
      this.plane.texture = newRenderTexture;

      // Cleanup old textures to prevent memory leaks
      if (oldTextTexture && oldTextTexture !== newTextTexture) oldTextTexture.destroy();
      if (oldRenderTexture && oldRenderTexture !== newRenderTexture) oldRenderTexture.destroy();
    }

    update(delta: number) {
      if (!this.plane) return;

      this.time += this.speed * delta;

      // Access geometry and buffer
      const geometry = this.plane.geometry;
      const attribute = geometry.getAttribute('aPosition');
      const buffer = attribute.buffer;
      
      // Store original positions if not already done
      if (!this.originalPositions) {
        this.originalPositions = Float32Array.from(buffer.data as Float32Array);
      }
      
      const original = this.originalPositions;
      const data = buffer.data as Float32Array;
      
      for (let i = 0; i < data.length; i += 2) {
        const x = original[i];
        const y = original[i + 1];
        
        // Diagonal wave effect
        // We calculate a phase based on both x and y to make the wave travel diagonally
        const angle = this.rotation * (Math.PI / 180);
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const phase = (x * cos + y * sin) * this.frequency * 0.01 + this.time;
        
        // Calculate displacement
        // We displace perpendicular to the wave direction or just Z-ish mapped to Y
        // Let's try a "bulge" effect
        const offset = Math.sin(phase) * this.amplitude;
        
        // Apply offset. 
        // For a "tissue" look, we might want to displace both X and Y slightly
        data[i] = x + offset * 0.5;
        data[i + 1] = y + offset * 0.5;
      }
      
      buffer.update();
    }
    
    destroy() {
      if (this.unsubscribeTheme) {
        this.unsubscribeTheme();
      }
      // v8 destroy options
      this.app.destroy({ removeView: true }, { children: true, texture: true });
    }
  }

  // Initialize all instances
  const containers = document.querySelectorAll('.portfolio-tissue-container');
  containers.forEach(container => {
    if (container instanceof HTMLElement) {
       const tissue = new PortfolioTissue(container);
       
       // Dev controls
       if (import.meta.env.DEV) {
         const freqSlider = container.querySelector('#freq-slider');
         const ampSlider = container.querySelector('#amp-slider');
         const speedSlider = container.querySelector('#speed-slider');
         
         const freqVal = container.querySelector('#freq-val');
         const ampVal = container.querySelector('#amp-val');
         const speedVal = container.querySelector('#speed-val');

         if (freqSlider && freqVal) {
           freqSlider.addEventListener('input', (e) => {
             const val = parseFloat((e.target as HTMLInputElement).value);
             tissue.frequency = val;
             freqVal.textContent = val.toFixed(1);
           });
         }

         if (ampSlider && ampVal) {
           ampSlider.addEventListener('input', (e) => {
             const val = parseFloat((e.target as HTMLInputElement).value);
             tissue.amplitude = val;
             ampVal.textContent = val.toFixed(0);
           });
         }

          if (speedSlider && speedVal) {
            speedSlider.addEventListener('input', (e) => {
              const val = parseFloat((e.target as HTMLInputElement).value);
              tissue.speed = val;
              speedVal.textContent = val.toFixed(2);
            });
          }

          const rotSlider = container.querySelector('#rot-slider');
          const rotVal = container.querySelector('#rot-val');
          if (rotSlider && rotVal) {
            rotSlider.addEventListener('input', (e) => {
              const val = parseFloat((e.target as HTMLInputElement).value);
              tissue.rotation = val;
              rotVal.textContent = val.toFixed(0);
            });
          }
       }
       
       // Cleanup on swap
       document.addEventListener('astro:before-swap', () => {
           tissue.destroy();
       }, { once: true });
    }
  });
</script>

