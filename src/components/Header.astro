<header class="fixed top-0 inset-x-0 h-[60px] bg-background z-5">
	<div class="absolute inset-0 size-full">
		<svg class="size-full">
			<rect x="0" y="0" width="100%" height="100%" fill="url(#square-grid)"></rect>
		</svg>
	</div>

	<div class="absolute inset-0 size-full masked-reveal bg-background">
		<svg class="size-full">
			<rect x="0" y="0" width="100%" height="100%" fill="url(#checkerboard)"></rect>
		</svg>
	</div>

	<div class="absolute inset-0 size-full">
		<svg
			viewBox="0 0 100 100"
			class="size-full overflow-visible"
			preserveAspectRatio="none"
			aria-hidden="true"
			data-wave-line
		>
			<path id="wave-line-path" d="M0 100 L100 100" stroke="currentColor" stroke-width="0.75" fill="none"></path>
		</svg>
	</div>
</header>

<script>
	import { gsap } from "gsap";

	const initWaveLine = () => {
		const svg = document.querySelector<SVGSVGElement>("[data-wave-line]");
		const path = svg?.querySelector<SVGPathElement>("#wave-line-path");
		if (!svg || !path) return;

		const baseY = 100;
		const segments = 80;
		const points = Array.from({ length: segments }, (_, i) => ({
			x: (i / (segments - 1)) * 100,
			y: baseY,
		}));

		let mouseX = 50;
		let phase = 0;
		let isActive = false;
		let idleTimeout: gsap.core.Tween | null = null;
		let ampTween: gsap.core.Tween | null = null;
		const ampState = { value: 0 };

		const config = { amp: 15, decay: 0.1, freq: 0.55, speed: 0.2, fadeDuration: 0.95 };
		const nearLineThreshold = 6;
		const idleDelay = 0.9;

		const render = () => {
			const d = points.map((p, i) => `${i === 0 ? "M" : "L"}${p.x},${p.y}`).join(" ");
			path.setAttribute("d", d);
		};

		const updateWave = () => {
			phase += config.speed;

			for (const p of points) {
				const dx = p.x - mouseX;
				const dist = Math.abs(dx);
				const envelope = Math.exp(-dist * config.decay);
				const wave = Math.sin(dist * config.freq - phase);
				p.y = baseY + wave * config.amp * ampState.value * envelope;
			}

			render();
		};

		const start = () => {
			if (idleTimeout) {
				idleTimeout.kill();
				idleTimeout = null;
			}
			if (ampTween) {
				ampTween.kill();
				ampTween = null;
			}

			ampState.value = 1;

			if (!isActive) {
				isActive = true;
				gsap.ticker.add(updateWave);
			}
		};

		const startDecay = () => {
			if (!isActive) return;

			if (ampTween) ampTween.kill();
			ampTween = gsap.to(ampState, {
				value: 0,
				duration: config.fadeDuration,
				ease: "power2.out",
				onUpdate: render,
				onComplete: () => {
					ampTween = null;
					isActive = false;
					gsap.ticker.remove(updateWave);
					for (const p of points) p.y = baseY;
					render();
				},
			});
		};

		const scheduleStop = () => {
			if (idleTimeout) idleTimeout.kill();
			idleTimeout = gsap.delayedCall(idleDelay, () => {
				idleTimeout = null;
				startDecay();
			});
		};

		const handlePointerMove = (event: PointerEvent) => {
			const rect = svg.getBoundingClientRect();
			const ratioX = (event.clientX - rect.left) / rect.width;
			const ratioY = (event.clientY - rect.top) / rect.height;
			const x = Math.min(100, Math.max(0, ratioX * 100));
			const y = Math.min(100, Math.max(0, ratioY * 100));

			if (Math.abs(y - baseY) > nearLineThreshold) return;

			mouseX = x;
			start();
			scheduleStop();
		};

		svg.addEventListener("pointermove", handlePointerMove);
		svg.addEventListener("pointerleave", (event) => {
			const rect = svg.getBoundingClientRect();
			const ratioX = (event.clientX - rect.left) / rect.width;
			mouseX = Math.min(100, Math.max(0, ratioX * 100));
			start();
			scheduleStop();
		});

		render();
	};

	initWaveLine();
</script>
