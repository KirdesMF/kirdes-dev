---
// src/components/ElasticTitle.astro
---

<div id="elastic-title-container" class="w-full h-full min-h-[500px] relative overflow-hidden bg-[#0a0a0a]">
    <!-- Canvas will be injected here -->
</div>

<script>
    import { Application, Assets, Text, Sprite, Texture, Mesh, Shader, RenderTexture, PlaneGeometry, UniformGroup } from 'pixi.js';
    import gsap from 'gsap';

    const container = document.getElementById('elastic-title-container');

    if (container) {
        initPixi(container);
    }

    async function initPixi(container: HTMLElement) {
        // 1. Setup Application
        const app = new Application();
        await app.init({
            background: '#0a0a0a',
            resizeTo: container,
            antialias: true,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true,
        });
        container.appendChild(app.canvas);

        // 2. Create Text Texture
        const textStyle = {
            fontFamily: 'Arial, sans-serif',
            fontSize: 150,
            fontWeight: '900',
            fill: '#ffffff',
            align: 'center',
            letterSpacing: 10,
            padding: 50,
            stroke: '#000000',
            strokeThickness: 4,
        };
        const text = new Text({ text: 'Ã‰LASTIQUE', style: textStyle as any });
        
        // 3. Shader Logic
        // We need a custom shader that handles the "stack" of layers.
        
        // Create a RenderTexture to hold the text
        // We need to ensure the text is measured
        const renderTexture = RenderTexture.create({
            width: text.width,
            height: text.height,
            resolution: 2, // High res for crisp text
        });

        // Render the text to the texture
        app.renderer.render({ container: text, target: renderTexture });

        // Ensure texture clamping
        renderTexture.source.style.addressMode = 'clamp-to-edge';

        
        const vertexSrc = `#version 300 es
            precision mediump float;
            in vec2 aPosition;
            in vec2 aUV;
            
            out vec2 vUv;
            
            uniform mat3 uProjectionMatrix;
            uniform mat3 uWorldTransformMatrix;
            uniform mat3 uTransformMatrix;
            
            void main() {
                vUv = aUV;
                mat3 mvp = uProjectionMatrix * uWorldTransformMatrix * uTransformMatrix;
                gl_Position = vec4((mvp * vec3(aPosition, 1.0)).xy, 0.0, 1.0);
            }
        `;

        const fragmentSrc = `#version 300 es
            precision mediump float;

            in vec2 vUv;
            out vec4 fragColor;

            uniform sampler2D uTexture;
            uniform vec2 uLayerOffsets[20];
            uniform float uLayerAlphas[20];
            uniform vec2 uResolution;
            uniform vec2 uTextureSize;

            // Function to calculate distortion
            vec2 getDistortedUV(vec2 uv, vec2 offset) {
                vec2 center = vec2(0.5);
                float dist = distance(uv, center);
                float influence = exp(-dist * dist * 8.0);
                return uv - offset * influence;
            }

            void main() {
                vec4 finalColor = vec4(0.0);
                
                for (int i = 19; i >= 0; i--) {
                    vec2 offset = uLayerOffsets[i];
                    
                    // Calculate scale for depth (perspective)
                    // Back layers should be smaller to recede (scale > 1.0 in UV space)
                    float depthFactor = float(i) / 20.0;
                    float scale = 1.0 + depthFactor * 0.1;
                    
                    // Apply scaling from center
                    vec2 centeredUV = vUv - 0.5;
                    vec2 scaledUV = centeredUV * scale + 0.5;
                    
                    vec2 distortedUV = getDistortedUV(scaledUV, offset);
                    
                    // Check bounds
                    if (distortedUV.x < 0.0 || distortedUV.x > 1.0 || distortedUV.y < 0.0 || distortedUV.y > 1.0) {
                        continue;
                    }

                    vec4 texColor = texture(uTexture, distortedUV);
                    
                    // Apply depth darkening
                    // float depthFactor = float(i) / 20.0; // Already defined above
                    
                    // Darken back layers to create depth shadow
                    vec3 color = texColor.rgb * (1.0 - depthFactor * 0.6);
                    
                    // Use texture alpha, but keep layers mostly opaque to simulate solid volume
                    float alpha = texColor.a;
                    
                    // If alpha is low (transparent background), don't draw
                    if (alpha < 0.01) continue;

                    // Standard blending (Over operator)
                    // Since we draw back-to-front, this stacks layers correctly
                    finalColor = vec4(color * alpha, alpha) + finalColor * (1.0 - alpha);
                }

                fragColor = finalColor;
            }
        `;

        // Prepare Uniforms
        const numLayers = 20;
        const layerOffsets = new Float32Array(numLayers * 2); // x,y per layer
        const layerAlphas = new Float32Array(numLayers);
        
        // Init alphas
        for(let i=0; i<numLayers; i++) {
            layerAlphas[i] = 1.0 - (i / numLayers) * 0.8; // Fade out back layers
        }


        const uniformGroup = new UniformGroup({
            uLayerOffsets: { value: layerOffsets, type: 'vec2<f32>', size: 20 },
            uLayerAlphas: { value: layerAlphas, type: 'f32', size: 20 },
            uResolution: { value: { x: app.screen.width, y: app.screen.height }, type: 'vec2<f32>' },
            uTextureSize: { value: { x: text.width, y: text.height }, type: 'vec2<f32>' }
        }, { ubo: false }); // Disable UBO to match global uniforms in shader without std140 padding issues

        const shader = Shader.from({
            gl: {
                vertex: vertexSrc,
                fragment: fragmentSrc,
            },
            resources: {
                uTexture: renderTexture.source,
                uniforms: uniformGroup
            }
        });

        // Create a Quad Mesh to draw the shader
        // We want the mesh to be the size of the text (plus padding for distortion)
        const padding = 200;
        const width = text.width + padding * 2;
        const height = text.height + padding * 2;

        const geometry = new PlaneGeometry({
            width: width,
            height: height,
            verticesX: 2,
            verticesY: 2
        });

        const mesh = new Mesh({
            geometry,
            shader,
        });

        mesh.position.set(app.screen.width / 2, app.screen.height / 2);
        // Center the mesh pivot
        mesh.pivot.set(width / 2, height / 2);
        app.stage.addChild(mesh);

        // DEBUG: Check if renderTexture has content
        // const debugSprite = new Sprite(renderTexture);
        // debugSprite.anchor.set(0.5);
        // debugSprite.position.set(app.screen.width / 2, app.screen.height / 2);
        // app.stage.addChild(debugSprite);

        // 4. Physics / Animation Logic
        // We simulate a chain of points.
        // points[0] is the "head" (pulled by mouse)
        // points[1..N] follow with spring physics
        
        const points: {x: number, y: number, vx: number, vy: number}[] = [];
        for (let i = 0; i < numLayers; i++) {
            // Initialize at 0. Static offset is added in the render loop.
            points.push({ x: 0, y: 0, vx: 0, vy: 0 });
        }

        let isDragging = false;
        let dragTarget = { x: 0, y: 0 };
        
        // Spring constants - Tuned for "heavy" elastic feel
        const tension = 0.1; // Lower tension = more lag/drag
        const friction = 0.9; // Higher friction = less bounce/jitter

        // Interaction
        app.stage.eventMode = 'static';
        app.stage.hitArea = app.screen;
        
        app.stage.on('pointerdown', (e) => {
            isDragging = true;
            updateDragTarget(e.global);
        });

        app.stage.on('pointermove', (e) => {
            if (isDragging) {
                updateDragTarget(e.global);
            }
        });

        const onRelease = () => {
            if (!isDragging) return;
            isDragging = false;
            
            // Animate the "Head" (dragTarget) back to 0,0 with GSAP Elastic
            // We animate an object, and the ticker updates points[0] to follow it?
            // Or we animate points[0] directly?
            // Let's animate dragTarget, and points[0] follows dragTarget immediately or with physics?
            // The user wants "Animation de Release... GSAP... elastic.out".
            // Let's animate the dragTarget coordinates to 0.
            
            gsap.to(dragTarget, {
                x: 0,
                y: 0,
                duration: 1,
                ease: "elastic.out(1, 0.3)",
                onUpdate: () => {
                    // Ticker will pick up the new dragTarget
                }
            });
        };

        app.stage.on('pointerup', onRelease);
        app.stage.on('pointerupoutside', onRelease);

        function updateDragTarget(globalPos: { x: number, y: number }) {
            // Convert global to local relative to center
            const centerX = app.screen.width / 2;
            const centerY = app.screen.height / 2;
            
            // Limit the drag distance to avoid extreme distortion
            let dx = globalPos.x - centerX;
            let dy = globalPos.y - centerY;
            
            // Normalize to UV space-ish scale?
            // The shader expects offsets in UV coordinates (0-1).
            // So we need to map pixels to UV offset.
            // Texture width/height is `width`, `height`.
            
            const maxDist = 300;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > maxDist) {
                const angle = Math.atan2(dy, dx);
                dx = Math.cos(angle) * maxDist;
                dy = Math.sin(angle) * maxDist;
            }

            dragTarget.x = dx / width; // Normalize by mesh size
            dragTarget.y = dy / height;
        }

        // Ticker
        app.ticker.add(() => {
            // Update Head
            
            // Dynamic physics constants
            // Dragging: High damping (low friction factor), tighter tension -> Smooth follow, no bounce
            // Release: Low damping (high friction factor), looser tension -> Elastic, bouncy feel
            const currentTension = isDragging ? 0.3 : 0.1;
            const currentFriction = isDragging ? 0.5 : 0.9;

            // 1. Update first point (follows dragTarget)
            const leader = points[0];
            const dx = dragTarget.x - leader.x;
            const dy = dragTarget.y - leader.y;
            
            leader.vx += dx * currentTension;
            leader.vy += dy * currentTension;
            leader.vx *= currentFriction;
            leader.vy *= currentFriction;
            leader.x += leader.vx;
            leader.y += leader.vy;

            // 2. Update rest of the chain
            for (let i = 1; i < numLayers; i++) {
                const prev = points[i - 1];
                const curr = points[i];

                const dx = prev.x - curr.x;
                const dy = prev.y - curr.y;

                curr.vx += dx * currentTension;
                curr.vy += dy * currentTension;
                curr.vx *= currentFriction;
                curr.vy *= currentFriction;
                curr.x += curr.vx;
                curr.y += curr.vy;
            }

            // Update uniforms
            for (let i = 0; i < numLayers; i++) {
                // Add static offset to physics position to maintain "stack" look
                // Physics drives the deformation, static offset drives the depth
                const staticOffsetX = i * 0.005;
                const staticOffsetY = i * 0.005;
                
                layerOffsets[i * 2] = points[i].x + staticOffsetX;
                layerOffsets[i * 2 + 1] = points[i].y + staticOffsetY;
                
                // layerAlphas[i] = 1.0 - (i / numLayers) * 0.8;
            }
            // Trigger uniform update
            // With UniformGroup, we can just re-assign or rely on the group update
            // Re-assigning the value ensures the dirty flag is set if needed
            uniformGroup.uniforms.uLayerOffsets = layerOffsets;
            
        });
        
        // Handle Resize
        window.addEventListener('resize', () => {
            app.resize();
            mesh.position.set(app.screen.width / 2, app.screen.height / 2);
            uniformGroup.uniforms.uResolution = { x: app.screen.width, y: app.screen.height };
        });
    }
</script>
