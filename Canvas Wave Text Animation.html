<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Commissioner:wght@700;800&display=swap" rel="stylesheet" />
    <title>Canvas Wave Text Invert Playground</title>
    <style>
      :root {
        --bg: #0e0e10;
        --fg: #f3f5f7;
        --stage-w: min(90vw, 1200px);
        --stage-h: min(70vh, 700px);
      }
      html,
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font-family:
          "Commissioner",
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Ubuntu,
          Cantarell,
          "Helvetica Neue",
          Arial,
          "Noto Sans";
        min-height: 100svh;
        display: grid;
        place-items: center;
      }
      .wrap {
        position: relative;
        width: var(--stage-w);
        height: var(--stage-h);
        isolation: isolate;
        border-radius: 16px;
        overflow: hidden;
        box-shadow:
          0 20px 60px rgba(0, 0, 0, 0.45),
          0 2px 8px rgba(0, 0, 0, 0.35);
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      .ui {
        position: fixed;
        top: 12px;
        left: 12px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(6px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        line-height: 1.4;
        user-select: none;
        width: min(380px, 92vw);
        max-height: calc(100svh - 24px);
        overflow: auto;
      }
      .ui label {
        display: grid;
        grid-template-columns: 130px 1fr;
        gap: 8px;
        align-items: center;
        margin: 6px 0;
      }
      .ui input[type="text"] {
        width: 230px;
        background: transparent;
        color: var(--fg);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 8px;
        padding: 6px 8px;
      }
      .ui input[type="range"] {
        width: 230px;
      }
      .swatch {
        width: 22px;
        height: 22px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.35);
        display: inline-block;
        vertical-align: middle;
        margin-left: 8px;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .sep {
        opacity: 0.25;
        border: none;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        margin: 6px 0;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <canvas id="c"></canvas>
    </div>

    <div class="ui">
      <details open>
        <summary>Réglages</summary>
        <div class="row">
          <label>Texte <input id="text" type="text" value="HOCUSBOOKUS" /></label>
        </div>
        <div class="row">
          <label class="row" style="gap: 8px; grid-template-columns: auto auto"
            ><input id="textTiled" type="checkbox" /> Remplir en diagonale</label
          >
        </div>
        <div class="row">
          <label>Angle (°) <input id="textAngle" type="range" min="-90" max="90" step="1" value="-30" /></label
          ><span id="textAngleVal">-30°</span>
        </div>
        <div class="row">
          <label>Taille texte (×) <input id="textScale" type="range" min="0.5" max="2" step="0.05" value="1" /></label
          ><span id="textScaleVal">1.00×</span>
        </div>
        <div class="row">
          <label
            >Interligne (×) <input id="textLineGap" type="range" min="0.8" max="2.0" step="0.05" value="1.00" /></label
          ><span id="textLineGapVal">1.00×</span>
        </div>
        <div class="row">
          <label>Chasse (×) <input id="textHSpacing" type="range" min="0.5" max="2.0" step="0.05" value="1.00" /></label
          ><span id="textHSpacingVal">1.00×</span>
        </div>
        <div class="row">
          <label
            >Espacement lettres (px)
            <input id="letterSpacing" type="range" min="-5" max="20" step="0.5" value="0" /></label
          ><span id="letterSpacingVal">0.0 px</span>
        </div>
        <div class="row">
          <label
            >Défilement (px/s) <input id="textScrollSpeed" type="range" min="0" max="200" step="1" value="30" /></label
          ><span id="textScrollSpeedVal">30 px/s</span>
        </div>
        <div class="row">
          <label>Foreground <input id="fg" type="color" value="#f3f5f7" /></label><span class="swatch" id="fgSw"></span>
        </div>
        <div class="row">
          <label>Background <input id="bg" type="color" value="#0e0e10" /></label><span class="swatch" id="bgSw"></span>
        </div>
        <div class="row">
          <label>Segments <input id="amount" type="range" min="8" max="80" value="24" /></label
          ><span id="amountVal">24</span>
        </div>
        <div class="row">
          <label>Segments (max) <input id="amountMax" type="range" min="24" max="300" step="1" value="80" /></label
          ><span id="amountMaxVal">80</span>
        </div>
        <div class="row">
          <label class="row" style="gap: 8px; grid-template-columns: auto auto"
            ><input id="fixEdges" type="checkbox" /> Fixer les bords (2 + 2)</label
          >
        </div>
        <div class="row">
          <label>Raideur (spring) <input id="strength" type="range" min="0" max="2" step="0.01" value="0.18" /></label
          ><span id="strengthVal">0.18</span>
        </div>
        <div class="row">
          <label>Friction <input id="friction" type="range" min="0" max="1" step="0.01" value="0.8" /></label
          ><span id="frictionVal">0.80</span>
        </div>
        <div class="row">
          <label
            >Rappel (baseline)
            <input id="baselinePull" type="range" min="0" max="0.1" step="0.001" value="0.02" /></label
          ><span id="baselinePullVal">0.020</span>
        </div>
        <div class="row">
          <label>Régularité <input id="regularity" type="range" min="0" max="0.5" step="0.01" value="0.15" /></label
          ><span id="regularityVal">0.15</span>
        </div>
        <div class="row">
          <label>Lissage (iters) <input id="smoothIters" type="range" min="0" max="5" step="1" value="2" /></label
          ><span id="smoothItersVal">2</span>
        </div>
        <div class="row">
          <label>Masse <input id="mass" type="range" min="0.5" max="5" step="0.1" value="2" /></label
          ><span id="massVal">2.0</span>
        </div>
        <div class="row">
          <label>Nudge <input id="nudge" type="range" min="0.2" max="3" step="0.1" value="1.0" /></label
          ><span id="nudgeVal">1.0×</span>
        </div>

        <hr class="sep" />
        <div class="row">
          <label class="row" style="gap: 8px; grid-template-columns: auto auto"
            ><input id="showStroke" type="checkbox" /> Ligne sur la vague</label
          >
        </div>
        <div class="row">
          <label>Tirets (px) <input id="dashLen" type="range" min="1" max="40" step="1" value="8" /></label
          ><span id="dashLenVal">8 px</span>
        </div>
        <div class="row">
          <label>Espacement (px) <input id="dashGap" type="range" min="0" max="40" step="1" value="8" /></label
          ><span id="dashGapVal">8 px</span>
        </div>
        <div class="row">
          <label>Épaisseur (px) <input id="strokeWidth" type="range" min="1" max="8" step="0.5" value="2" /></label
          ><span id="strokeWidthVal">2.0 px</span>
        </div>
        <div class="row">
          <label
            >Défilement tirets (px/s)
            <input id="dashSpeed" type="range" min="-300" max="300" step="1" value="60" /></label
          ><span id="dashSpeedVal">60 px/s</span>
        </div>

        <hr class="sep" />
        <div class="row">
          <label class="row" style="gap: 8px; grid-template-columns: auto auto"
            ><input id="idleEnabled" type="checkbox" checked /> Vague de repos</label
          >
        </div>
        <div class="row">
          <label>Amplitude repos (px) <input id="idleAmp" type="range" min="0" max="12" step="0.01" value="3" /></label
          ><span id="idleAmpVal">3.00 px</span>
        </div>
        <div class="row">
          <label
            >Fréquence repos (Hz)
            <input id="idleHz" type="range" min="0.001" max="0.50" step="0.001" value="0.080" /></label
          ><span id="idleHzVal">0.080 Hz</span>
        </div>
        <div class="row">
          <label
            >Longueur d’onde (× largeur)
            <input id="idleLambda" type="range" min="0.25" max="6.00" step="0.01" value="1.00" /></label
          ><span id="idleLambdaVal">1.00×</span>
        </div>
        <div class="row">
          <label>Phase repos (°) <input id="idlePhase" type="range" min="-180" max="180" step="1" value="0" /></label
          ><span id="idlePhaseVal">0°</span>
        </div>
        <div class="row">
          <label
            >Délai reprise (s)
            <input id="idleResumeSec" type="range" min="0.2" max="4.0" step="0.1" value="1.2" /></label
          ><span id="idleResumeSecVal">1.2 s</span>
        </div>

        <hr class="sep" />
        <div class="row">
          <label class="row" style="gap: 8px; grid-template-columns: auto auto"
            ><input id="loupeEnabled" type="checkbox" /> Loupe pattern (hover)</label
          >
        </div>
        <div class="row">
          <label>Rayon loupe (px) <input id="loupeRadius" type="range" min="40" max="300" step="1" value="160" /></label
          ><span id="loupeRadiusVal">160 px</span>
        </div>
        <div class="row">
          <label
            >Pattern scale (×)
            <input id="patternScale" type="range" min="0.25" max="4.00" step="0.01" value="1.00" /></label
          ><span id="patternScaleVal">1.00×</span>
        </div>
        <div class="row">
          <label
            >Pattern rotation (°) <input id="patternRot" type="range" min="-180" max="180" step="1" value="0" /></label
          ><span id="patternRotVal">0°</span>
        </div>
        <div class="row">
          <label class="row" style="gap: 8px; grid-template-columns: auto auto"
            ><input id="loupeOutline" type="checkbox" checked /> Outline dans la loupe</label
          >
        </div>
        <div class="row">
          <label
            >Épaisseur outline (px)
            <input id="loupeOutlineW" type="range" min="0.5" max="6" step="0.5" value="2.0" /></label
          ><span id="loupeOutlineWVal">2.0 px</span>
        </div>
        <div class="row">
          <label class="row" style="gap: 8px; grid-template-columns: auto auto"
            ><input id="loupeBorder" type="checkbox" checked /> Contour du cercle</label
          >
        </div>
        <div class="row">
          <label
            >Épaisseur contour (px)
            <input id="loupeBorderW" type="range" min="1" max="6" step="0.5" value="1.5" /></label
          ><span id="loupeBorderWVal">1.5 px</span>
        </div>
      </details>
    </div>

    <script>
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");

      // UI
      const uiText = document.getElementById("text");
      const uiTextTiled = document.getElementById("textTiled");
      const uiTextAngle = document.getElementById("textAngle");
      const textAngleVal = document.getElementById("textAngleVal");
      const uiTextScale = document.getElementById("textScale");
      const textScaleVal = document.getElementById("textScaleVal");
      const uiTextLineGap = document.getElementById("textLineGap");
      const textLineGapVal = document.getElementById("textLineGapVal");
      const uiTextHSpacing = document.getElementById("textHSpacing");
      const textHSpacingVal = document.getElementById("textHSpacingVal");
      const uiLetterSpacing = document.getElementById("letterSpacing");
      const letterSpacingVal = document.getElementById("letterSpacingVal");
      const uiTextScrollSpeed = document.getElementById("textScrollSpeed");
      const textScrollSpeedVal = document.getElementById("textScrollSpeedVal");
      const uiFG = document.getElementById("fg");
      const uiBG = document.getElementById("bg");
      const fgSw = document.getElementById("fgSw");
      const bgSw = document.getElementById("bgSw");
      const uiAmount = document.getElementById("amount");
      const amountVal = document.getElementById("amountVal");
      const uiAmountMax = document.getElementById("amountMax");
      const amountMaxVal = document.getElementById("amountMaxVal");
      const uiFixEdges = document.getElementById("fixEdges");
      const uiStrength = document.getElementById("strength");
      const strengthVal = document.getElementById("strengthVal");
      const uiFriction = document.getElementById("friction");
      const frictionVal = document.getElementById("frictionVal");
      const uiRegularity = document.getElementById("regularity");
      const regularityVal = document.getElementById("regularityVal");
      const uiSmoothIters = document.getElementById("smoothIters");
      const smoothItersVal = document.getElementById("smoothItersVal");
      const uiMass = document.getElementById("mass");
      const massVal = document.getElementById("massVal");
      const uiNudge = document.getElementById("nudge");
      const nudgeVal = document.getElementById("nudgeVal");
      const uiBaselinePull = document.getElementById("baselinePull");
      const baselinePullVal = document.getElementById("baselinePullVal");
      const uiShowStroke = document.getElementById("showStroke");
      const uiDashLen = document.getElementById("dashLen");
      const dashLenVal = document.getElementById("dashLenVal");
      const uiDashGap = document.getElementById("dashGap");
      const dashGapVal = document.getElementById("dashGapVal");
      const uiStrokeWidth = document.getElementById("strokeWidth");
      const strokeWidthVal = document.getElementById("strokeWidthVal");
      const uiDashSpeed = document.getElementById("dashSpeed");
      const dashSpeedVal = document.getElementById("dashSpeedVal");
      const uiIdleEnabled = document.getElementById("idleEnabled");
      const uiIdleAmp = document.getElementById("idleAmp");
      const idleAmpVal = document.getElementById("idleAmpVal");
      const uiIdleHz = document.getElementById("idleHz");
      const idleHzVal = document.getElementById("idleHzVal");
      const uiIdleResumeSec = document.getElementById("idleResumeSec");
      const idleResumeSecVal = document.getElementById("idleResumeSecVal");
      const uiIdlePhase = document.getElementById("idlePhase");
      const idlePhaseVal = document.getElementById("idlePhaseVal");
      const uiIdleLambda = document.getElementById("idleLambda");
      const idleLambdaVal = document.getElementById("idleLambdaVal");

      // Loupe controls
      const uiLoupeEnabled = document.getElementById("loupeEnabled");
      const uiLoupeRadius = document.getElementById("loupeRadius");
      const loupeRadiusVal = document.getElementById("loupeRadiusVal");
      const uiPatternScale = document.getElementById("patternScale");
      const patternScaleVal = document.getElementById("patternScaleVal");
      const uiPatternRot = document.getElementById("patternRot");
      const patternRotVal = document.getElementById("patternRotVal");
      const uiLoupeOutline = document.getElementById("loupeOutline");
      const uiLoupeOutlineW = document.getElementById("loupeOutlineW");
      const loupeOutlineWVal = document.getElementById("loupeOutlineWVal");
      const uiLoupeBorder = document.getElementById("loupeBorder");
      const uiLoupeBorderW = document.getElementById("loupeBorderW");
      const loupeBorderWVal = document.getElementById("loupeBorderWVal");

      let DPR = 1;

      const values = {
        friction: 0.8,
        timeStep: 0.016,
        amount: 24,
        mass: 2,
        regularity: 0.15,
        baselinePull: 0.02,
        smoothIters: 2,
        nudge: 1.0,
        fixEdges: false,
        textTiled: false,
        textAngleDeg: -30,
        textScale: 1,
        textLineGap: 1.0,
        textHSpacing: 1.0,
        letterSpacing: 0.0,
        textScrollSpeed: 30,
        textScrollPx: 0,
        showStroke: false,
        dashLen: 8,
        dashGap: 8,
        strokeWidth: 2,
        dashSpeed: 60,
        dashPhase: 0,
        idleEnabled: true,
        idleAmp: 3,
        idleHz: 0.08,
        idleResumeSec: 1.2,
        idlePhaseDeg: 0,
        idleLambda: 1.0,
        // Loupe pattern
        loupeEnabled: false,
        loupeRadius: 160,
        patternScale: 1.0,
        patternRotDeg: 0,
        loupeOutline: true,
        loupeOutlineW: 2.0,
        loupeBorder: true,
        loupeBorderW: 1.5,
        get invMass() {
          return 1 / this.mass;
        },
      };

      let points = [];
      let springs = [];
      let offCanvas = null,
        offCtx = null;
      let w = 0,
        h = 0;
      let textY = 0; // baseline Y for the text
      let tSec = 0; // time (s)
      let idleSuppress = 0; // 0..1 suppression after interaction

      class Spring {
        constructor(a, b, strength = 0.18, restLength = 80) {
          this.a = a;
          this.b = b;
          this.restLength = restLength;
          this.strength = strength;
          this.mamb = values.invMass * values.invMass;
        }
        update() {
          const dx = this.b.x - this.a.x;
          const dyFull = this.b.y - this.a.y;
          const dist = Math.hypot(dx, dyFull) || 1e-6;
          const normDistStrength = ((dist - this.restLength) / (dist * this.mamb)) * this.strength;
          const dy = dyFull * normDistStrength * values.invMass * 0.2;
          if (!this.a.fixed) this.a.y += dy;
          if (!this.b.fixed) this.b.y -= dy;
        }
      }

      function ensureOffscreen(rect) {
        if (!offCanvas) {
          offCanvas = document.createElement("canvas");
          offCtx = offCanvas.getContext("2d");
        }
        const cssW = Math.floor(rect.width);
        const cssH = Math.floor(rect.height);

        if (offCanvas.width !== cssW || offCanvas.height !== cssH) {
          offCanvas.width = cssW;
          offCanvas.height = cssH;
        }
        offCtx.setTransform(1, 0, 0, 1, 0, 0);
      }

      function setCanvasSize() {
        const rect = canvas.getBoundingClientRect();
        if (rect.width < 2 || rect.height < 2) return; // guard
        DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        w = Math.floor(rect.width * DPR);
        h = Math.floor(rect.height * DPR);
        canvas.width = w;
        canvas.height = h;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(DPR, DPR);
        ensureOffscreen(rect);
        fgSw.style.background = uiFG.value;
        bgSw.style.background = uiBG.value;
        document.documentElement.style.setProperty("--bg", uiBG.value);
        document.documentElement.style.setProperty("--fg", uiFG.value);
        textY = rect.height * 0.5;
        rebuild(values.amount);
        selfCheck("after resize");
      }

      function rebuild(amount) {
        const rect = canvas.getBoundingClientRect();
        const size = { width: rect.width, height: rect.height };
        points = [];
        springs = [];
        for (let i = 0; i <= amount; i++) {
          const x = (i / amount) * size.width;
          const y = rect.height * 0.5;
          const px = i === 0 ? 0 : i === amount ? size.width : x;
          const p = { x: px, y, px: px, py: y, fixed: values.fixEdges && (i < 2 || i > amount - 2) };
          points.push(p);
          if (i > 0) {
            const prev = points[i - 1];
            const rest = Math.hypot(p.x - prev.x, p.y - prev.y);
            springs.push(new Spring(prev, p, parseFloat(uiStrength.value), rest));
          }
        }
      }

      function update() {
        const rect = canvas.getBoundingClientRect();
        const H = rect.height,
          baseY = rect.height * 0.5;
        const force = 1 - values.friction * values.timeStep * values.timeStep;
        for (let i = 0; i < points.length; i++) {
          const p = points[i];
          if (p.fixed) {
            p.py = p.y = baseY;
            continue;
          }
          const dy = (p.y - p.py) * force;
          p.py = p.y;
          p.y += dy;
          p.y += (baseY - p.y) * values.baselinePull;
          const idleFactor = values.idleEnabled ? 1 - idleSuppress : 0;
          if (idleFactor > 0) {
            const phaseAcross = i / Math.max(1, points.length - 1);
            const phase =
              2 * Math.PI * (values.idleLambda * phaseAcross - tSec * values.idleHz) +
              (values.idlePhaseDeg * Math.PI) / 180;
            p.y += idleFactor * values.idleAmp * Math.sin(phase);
          }
          p.y = Math.max(0, Math.min(H, p.y));
        }
        for (let s of springs) s.update();
        for (let i = 0; i < points.length; i++) {
          const p = points[i];
          p.y = Math.max(0, Math.min(H, p.y));
        }
        const iters = values.smoothIters | 0;
        for (let t = 0; t < iters; t++) {
          const snap = points.map((p) => p.y);
          for (let i = 1; i < points.length - 1; i++) {
            const p = points[i];
            if (p.fixed) continue;
            p.y += (snap[i - 1] + snap[i + 1] - 2 * snap[i]) * values.regularity;
            p.y = Math.max(0, Math.min(H, p.y));
          }
        }
      }

      function pathWave(ctx2d) {
        const rect = canvas.getBoundingClientRect();
        const pts = points;
        if (pts.length < 2) return;
        ctx2d.beginPath();
        ctx2d.moveTo(0, rect.height);
        ctx2d.lineTo(pts[0].x, pts[0].y);
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = pts[Math.max(0, i - 1)],
            p1 = pts[i],
            p2 = pts[i + 1],
            p3 = pts[Math.min(pts.length - 1, i + 2)];
          const cp1x = p1.x + (p2.x - p0.x) / 6,
            cp1y = p1.y + (p2.y - p0.y) / 6;
          const cp2x = p2.x - (p3.x - p1.x) / 6,
            cp2y = p2.y - (p3.y - p1.y) / 6;
          ctx2d.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }
        ctx2d.lineTo(rect.width, rect.height);
        ctx2d.lineTo(0, rect.height);
        ctx2d.closePath();
      }

      function pathWaveCurve(ctx2d) {
        const pts = points;
        if (pts.length < 2) return;
        ctx2d.beginPath();
        ctx2d.moveTo(pts[0].x, pts[0].y);
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = pts[Math.max(0, i - 1)],
            p1 = pts[i],
            p2 = pts[i + 1],
            p3 = pts[Math.min(pts.length - 1, i + 2)];
          const cp1x = p1.x + (p2.x - p0.x) / 6,
            cp1y = p1.y + (p2.y - p0.y) / 6;
          const cp2x = p2.x - (p3.x - p1.x) / 6,
            cp2y = p2.y - (p3.y - p1.y) / 6;
          ctx2d.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }
      }

      function draw() {
        const rect = canvas.getBoundingClientRect();
        if (rect.width < 2 || rect.height < 2) return;
        ensureOffscreen(rect);
        const fg = uiFG.value,
          bg = uiBG.value;

        ctx.clearRect(0, 0, rect.width, rect.height);
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, rect.width, rect.height);

        pathWave(ctx);
        ctx.fillStyle = fg;
        ctx.fill();

        if (values.showStroke) {
          ctx.save();
          ctx.lineWidth = values.strokeWidth;
          ctx.setLineDash([Math.max(1, values.dashLen), Math.max(0, values.dashGap)]);
          ctx.lineDashOffset = -(values.dashPhase % Math.max(1, values.dashLen + values.dashGap));
          ctx.strokeStyle = fg;
          pathWaveCurve(ctx);
          ctx.stroke();
          ctx.restore();
        }

        drawTextLayer(ctx, fg);

        offCtx.clearRect(0, 0, rect.width, rect.height);
        drawTextLayer(offCtx, bg);
        offCtx.globalCompositeOperation = "destination-in";
        pathWave(offCtx);
        offCtx.fill();
        offCtx.globalCompositeOperation = "source-over";
        ctx.drawImage(offCanvas, 0, 0);

        // Loupe pattern overlay
        if (values.loupeEnabled && hoverActive) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(pointer.x, pointer.y, values.loupeRadius, 0, Math.PI * 2);
          ctx.clip();

          // Stripe pattern made of filled bands to avoid horizontal seams
          const makeStripePattern = (color) => {
            const S = 96,
              band = 12,
              gap = 24; // base units before scaling
            const tile = document.createElement("canvas");
            tile.width = S;
            tile.height = S;
            const t = tile.getContext("2d");
            t.clearRect(0, 0, S, S);
            t.fillStyle = color;
            t.save();
            t.translate(S / 2, S / 2);
            t.rotate(Math.PI / 4);
            t.fillRect(-band / 2, -S, band, 2 * S);
            t.fillRect(-band / 2 - gap, -S, band, 2 * S);
            t.fillRect(-band / 2 + gap, -S, band, 2 * S);
            t.restore();
            return tile;
          };
          const pat = ctx.createPattern(makeStripePattern(fg), "repeat");
          if (pat && pat.setTransform) {
            const s = Math.max(0.01, values.patternScale || 1);
            const m = new DOMMatrix().scale(s, s).rotate(values.patternRotDeg || 0);
            pat.setTransform(m);
          }
          ctx.fillStyle = pat;
          drawTextLayerPattern(ctx);
          if (values.loupeOutline) {
            ctx.lineWidth = values.loupeOutlineW;
            ctx.strokeStyle = fg;
            drawTextLayerOutline(ctx);
          }
          ctx.restore();

          if (values.loupeBorder) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(pointer.x, pointer.y, values.loupeRadius + 0.5, 0, Math.PI * 2);
            ctx.strokeStyle = fg;
            ctx.lineWidth = values.loupeBorderW;
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      const pointer = { x: 0, y: 0, down: false };
      let hoverActive = false;
      function onPointerMove(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        pointer.x = x;
        pointer.y = y;
        const amount = points.length - 1;
        if (amount < 2) return;
        const firstX = points[0].x,
          lastX = points[amount].x,
          span = Math.max(1e-6, lastX - firstX);
        const t = (x - firstX) / span;
        let i = Math.max(0, Math.min(amount, Math.round(t * amount)));
        const influence = rect.height / 4;
        const nudge = (idx, k) => {
          if (idx < 0 || idx > amount) return;
          const p = points[idx];
          if (p.fixed) return;
          const d = Math.hypot(p.x - x, p.y - y);
          if (d < influence) p.y += (y - p.y) * k;
        };
        nudge(i, (1 / 6) * values.nudge);
        nudge(i - 1, (1 / 24) * values.nudge);
        nudge(i + 1, (1 / 24) * values.nudge);
        idleSuppress = 1;
      }
      canvas.addEventListener("mousemove", onPointerMove, { passive: true });
      canvas.addEventListener("touchmove", onPointerMove, { passive: true });
      canvas.addEventListener("mouseenter", () => (hoverActive = true));
      canvas.addEventListener("mouseleave", () => (hoverActive = false));
      canvas.addEventListener("touchstart", () => (hoverActive = true), { passive: true });
      canvas.addEventListener("touchend", () => (hoverActive = false), { passive: true });

      // Controls
      uiAmount.addEventListener("input", () => {
        const max = parseInt(uiAmountMax.value, 10);
        if (parseInt(uiAmount.value, 10) > max) uiAmount.value = String(max);
        values.amount = parseInt(uiAmount.value, 10);
        amountVal.textContent = values.amount;
        rebuild(values.amount);
        selfCheck("after amount change");
      });
      uiStrength.addEventListener("input", () => {
        strengthVal.textContent = parseFloat(uiStrength.value).toFixed(2);
        for (const s of springs) s.strength = parseFloat(uiStrength.value);
      });
      uiAmountMax.addEventListener("input", () => {
        const max = parseInt(uiAmountMax.value, 10);
        amountMaxVal.textContent = String(max);
        uiAmount.max = String(max);
        if (parseInt(uiAmount.value, 10) > max) uiAmount.value = String(max);
      });
      uiFixEdges.addEventListener("change", () => {
        values.fixEdges = uiFixEdges.checked;
        rebuild(values.amount);
      });
      uiFriction.addEventListener("input", () => {
        values.friction = parseFloat(uiFriction.value);
        frictionVal.textContent = values.friction.toFixed(2);
      });
      uiBaselinePull.addEventListener("input", () => {
        values.baselinePull = parseFloat(uiBaselinePull.value);
        baselinePullVal.textContent = values.baselinePull.toFixed(3);
      });
      uiFG.addEventListener("input", () => (fgSw.style.background = uiFG.value));
      uiTextTiled.addEventListener("change", () => {
        values.textTiled = uiTextTiled.checked;
      });
      uiTextAngle.addEventListener("input", () => {
        values.textAngleDeg = parseInt(uiTextAngle.value, 10);
        textAngleVal.textContent = `${values.textAngleDeg}°`;
      });
      uiTextScale.addEventListener("input", () => {
        values.textScale = parseFloat(uiTextScale.value);
        textScaleVal.textContent = `${values.textScale.toFixed(2)}×`;
      });
      uiTextLineGap.addEventListener("input", () => {
        values.textLineGap = parseFloat(uiTextLineGap.value);
        textLineGapVal.textContent = `${values.textLineGap.toFixed(2)}×`;
      });
      uiTextHSpacing.addEventListener("input", () => {
        values.textHSpacing = parseFloat(uiTextHSpacing.value);
        textHSpacingVal.textContent = `${values.textHSpacing.toFixed(2)}×`;
      });
      uiLetterSpacing.addEventListener("input", () => {
        values.letterSpacing = parseFloat(uiLetterSpacing.value);
        letterSpacingVal.textContent = `${values.letterSpacing.toFixed(1)} px`;
      });
      uiTextScrollSpeed.addEventListener("input", () => {
        values.textScrollSpeed = parseFloat(uiTextScrollSpeed.value);
        textScrollSpeedVal.textContent = `${values.textScrollSpeed.toFixed(0)} px/s`;
      });
      uiBG.addEventListener("input", () => {
        bgSw.style.background = uiBG.value;
        document.documentElement.style.setProperty("--bg", uiBG.value);
        document.documentElement.style.setProperty("--fg", uiFG.value);
      });
      uiRegularity.addEventListener("input", () => {
        values.regularity = parseFloat(uiRegularity.value);
        regularityVal.textContent = values.regularity.toFixed(2);
      });
      uiSmoothIters.addEventListener("input", () => {
        values.smoothIters = parseInt(uiSmoothIters.value, 10);
        smoothItersVal.textContent = values.smoothIters.toString();
      });
      uiMass.addEventListener("input", () => {
        values.mass = parseFloat(uiMass.value);
        massVal.textContent = values.mass.toFixed(1);
        const mamb = (1 / values.mass) * (1 / values.mass);
        for (const s of springs) s.mamb = mamb;
      });
      uiNudge.addEventListener("input", () => {
        values.nudge = parseFloat(uiNudge.value);
        nudgeVal.textContent = values.nudge.toFixed(1) + "×";
      });
      uiShowStroke.addEventListener("change", () => {
        values.showStroke = uiShowStroke.checked;
      });
      uiDashLen.addEventListener("input", () => {
        values.dashLen = parseFloat(uiDashLen.value);
        dashLenVal.textContent = `${values.dashLen.toFixed(0)} px`;
      });
      uiDashGap.addEventListener("input", () => {
        values.dashGap = parseFloat(uiDashGap.value);
        dashGapVal.textContent = `${values.dashGap.toFixed(0)} px`;
      });
      uiStrokeWidth.addEventListener("input", () => {
        values.strokeWidth = parseFloat(uiStrokeWidth.value);
        strokeWidthVal.textContent = `${values.strokeWidth.toFixed(1)} px`;
      });
      uiDashSpeed.addEventListener("input", () => {
        values.dashSpeed = parseFloat(uiDashSpeed.value);
        dashSpeedVal.textContent = `${values.dashSpeed.toFixed(0)} px/s`;
      });
      uiIdleEnabled.addEventListener("change", () => {
        values.idleEnabled = uiIdleEnabled.checked;
      });
      uiIdleAmp.addEventListener("input", () => {
        values.idleAmp = parseFloat(uiIdleAmp.value);
        idleAmpVal.textContent = `${values.idleAmp.toFixed(2)} px`;
      });
      uiIdleHz.addEventListener("input", () => {
        values.idleHz = parseFloat(uiIdleHz.value);
        idleHzVal.textContent = `${values.idleHz.toFixed(3)} Hz`;
      });
      uiIdleResumeSec.addEventListener("input", () => {
        values.idleResumeSec = parseFloat(uiIdleResumeSec.value);
        idleResumeSecVal.textContent = `${values.idleResumeSec.toFixed(1)} s`;
      });
      uiIdlePhase.addEventListener("input", () => {
        values.idlePhaseDeg = parseInt(uiIdlePhase.value, 10) || 0;
        idlePhaseVal.textContent = `${values.idlePhaseDeg}\u00B0`;
      });
      uiIdleLambda.addEventListener("input", () => {
        values.idleLambda = parseFloat(uiIdleLambda.value);
        idleLambdaVal.textContent = `${values.idleLambda.toFixed(2)}×`;
      });

      // Loupe bindings
      uiLoupeEnabled.addEventListener("change", () => {
        values.loupeEnabled = uiLoupeEnabled.checked;
      });
      uiLoupeRadius.addEventListener("input", () => {
        values.loupeRadius = parseFloat(uiLoupeRadius.value);
        loupeRadiusVal.textContent = `${values.loupeRadius.toFixed(0)} px`;
      });
      uiPatternScale.addEventListener("input", () => {
        values.patternScale = parseFloat(uiPatternScale.value);
        patternScaleVal.textContent = `${values.patternScale.toFixed(2)}×`;
      });
      uiPatternRot.addEventListener("input", () => {
        values.patternRotDeg = parseInt(uiPatternRot.value, 10) || 0;
        patternRotVal.textContent = `${values.patternRotDeg}\u00B0`;
      });
      uiLoupeOutline.addEventListener("change", () => {
        values.loupeOutline = uiLoupeOutline.checked;
      });
      uiLoupeOutlineW.addEventListener("input", () => {
        values.loupeOutlineW = parseFloat(uiLoupeOutlineW.value);
        loupeOutlineWVal.textContent = `${values.loupeOutlineW.toFixed(1)} px`;
      });
      uiLoupeBorder.addEventListener("change", () => {
        values.loupeBorder = uiLoupeBorder.checked;
      });
      uiLoupeBorderW.addEventListener("input", () => {
        values.loupeBorderW = parseFloat(uiLoupeBorderW.value);
        loupeBorderWVal.textContent = `${values.loupeBorderW.toFixed(1)} px`;
      });

      // Tests (lightweight)
      function selfCheck(where = "") {
        const rect = canvas.getBoundingClientRect();
        console.assert(
          points.length === values.amount + 1,
          `[selfCheck ${where}] points length mismatch`,
          points.length,
          values.amount + 1,
        );
        console.assert(
          springs.length === points.length - 1,
          `[selfCheck ${where}] springs length mismatch`,
          springs.length,
          points.length - 1,
        );
        console.assert(points[0] && points[0].x === 0, `[selfCheck ${where}] first point not at x=0`, points[0]?.x);
        console.assert(
          points[points.length - 1] && Math.abs(points[points.length - 1].x - rect.width) < 0.5,
          `[selfCheck ${where}] last point not at x=width`,
          points[points.length - 1]?.x,
          rect.width,
        );
        console.assert(
          points.every((p, i, a) => i === 0 || a[i - 1].x <= p.x),
          `[selfCheck ${where}] x not monotonic`,
        );
      }

      function runTests() {
        const rect = canvas.getBoundingClientRect();
        const results = [];
        const add = (name, pass, info = "") => results.push({ name, pass, info });
        add("Endpoints anchored", points[0].x === 0 && Math.abs(points[points.length - 1].x - rect.width) < 0.5);
        add(
          "Monotonic X",
          points.every((p, i, a) => i === 0 || a[i - 1].x <= p.x),
        );
        add("Springs count", springs.length === points.length - 1);
        add("No fixed points (when toggle off)", !values.fixEdges ? points.every((p) => !p.fixed) : true);
        add(
          "Fixed edges respected (when on)",
          !values.fixEdges
            ? true
            : points.filter((p, i) => i < 2 || i > points.length - 3).every((p) => p.fixed) &&
                points.slice(2, -2).every((p) => !p.fixed),
        );
        const curvBefore = (() => {
          let s = 0;
          for (let i = 1; i < points.length - 1; i++) {
            const a = points[i - 1].y,
              b = points[i].y,
              c = points[i + 1].y;
            const d2 = a - 2 * b + c;
            s += d2 * d2;
          }
          return s;
        })();
        const curvAfter = (() => {
          let s = 0;
          for (let i = 1; i < points.length - 1; i++) {
            const a = points[i - 1].y,
              b = points[i].y,
              c = points[i + 1].y;
            const b2 = b + (a + c - 2 * b) * values.regularity;
            const d2 = a - 2 * b2 + c;
            s += d2 * d2;
          }
          return s;
        })();
        add("Curvature improves or stays stable", curvAfter <= curvBefore * 1.05, { curvBefore, curvAfter });
        const beforeYs = points.map((p) => p.y);
        update();
        const afterYs = points.map((p) => p.y);
        add(
          "Integration non-NaN and >= 0",
          afterYs.every((y) => Number.isFinite(y) && y >= 0),
        );
        add(
          "Y clamped within canvas",
          points.every((p) => p.y >= 0 && p.y <= rect.height),
        );
        const meanY = points.reduce((s, p) => s + p.y, 0) / points.length;
        const tol = rect.height * 0.45;
        add("Mean height near baseline", Math.abs(meanY - rect.height * 0.5) <= tol, {
          meanY,
          baseline: rect.height * 0.5,
        });
        let drew = true;
        try {
          draw();
        } catch (e) {
          drew = false;
        }
        add("draw() safe", drew);
        add("pathWaveCurve is function", typeof pathWaveCurve === "function");
        console.table(results);
        return results;
      }
      window.runTests = runTests;

      // Text helpers
      function measureSpaced(ctx2d, text, letterSpacing) {
        if (!text) return 0;
        if (!letterSpacing) return ctx2d.measureText(text).width;
        let w = 0;
        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          w += ctx2d.measureText(ch).width;
          if (i < text.length - 1) w += letterSpacing;
        }
        return w;
      }
      function fillTextSpaced(ctx2d, text, x, y, letterSpacing) {
        if (!text) return;
        if (!letterSpacing) {
          ctx2d.fillText(text, x, y);
          return;
        }
        let cx = x;
        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          ctx2d.fillText(ch, cx, y);
          cx += ctx2d.measureText(ch).width + letterSpacing;
        }
      }
      function strokeTextSpaced(ctx2d, text, x, y, letterSpacing) {
        if (!text) return;
        if (!letterSpacing) {
          ctx2d.strokeText(text, x, y);
          return;
        }
        let cx = x;
        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          ctx2d.strokeText(ch, cx, y);
          cx += ctx2d.measureText(ch).width + letterSpacing;
        }
      }

      function drawTextLayer(ctx2d, color) {
        const rect = canvas.getBoundingClientRect();
        const baseFontPx = Math.max(24, Math.min(160, rect.width * 0.12));
        const fontPx = baseFontPx * values.textScale;
        const fontStack =
          "'Commissioner', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial";
        ctx2d.fillStyle = color;
        ctx2d.textBaseline = "middle";
        if (!values.textTiled) {
          ctx2d.textAlign = "left";
          ctx2d.font = `800 ${fontPx}px ${fontStack}`;
          const tw = measureSpaced(ctx2d, uiText.value, values.letterSpacing);
          const startX = rect.width / 2 - tw / 2;
          fillTextSpaced(ctx2d, uiText.value, startX, textY, values.letterSpacing);
          return;
        }
        const angleRad = ((values.textAngleDeg || 0) * Math.PI) / 180;
        ctx2d.save();
        ctx2d.translate(rect.width / 2, rect.height / 2);
        ctx2d.rotate(angleRad);
        ctx2d.textAlign = "left";
        ctx2d.font = `800 ${fontPx}px ${fontStack}`;
        const sample = uiText.value || "";
        const diag = Math.hypot(rect.width, rect.height);
        const stepY = fontPx * (values.textLineGap || 1.0);
        const wordW = Math.max(1, measureSpaced(ctx2d, sample, values.letterSpacing));
        const stepX = Math.max(1, wordW * (values.textHSpacing || 1.0));
        for (let row = 0, y = -diag; y <= diag; row++, y += stepY) {
          const dir = row % 2 === 0 ? 1 : -1;
          const s = values.textScrollPx % stepX;
          ctx2d.save();
          ctx2d.translate(dir * s, 0);
          const startX = -diag - stepX;
          for (let x = startX; x <= diag + stepX; x += stepX) {
            fillTextSpaced(ctx2d, sample, x, y, values.letterSpacing);
          }
          ctx2d.restore();
        }
        ctx2d.restore();
      }
      function drawTextLayerPattern(ctx2d) {
        const rect = canvas.getBoundingClientRect();
        const baseFontPx = Math.max(24, Math.min(160, rect.width * 0.12));
        const fontPx = baseFontPx * values.textScale;
        const fontStack =
          "'Commissioner', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial";
        ctx2d.textBaseline = "middle";
        if (!values.textTiled) {
          ctx2d.textAlign = "left";
          ctx2d.font = `800 ${fontPx}px ${fontStack}`;
          const tw = measureSpaced(ctx2d, uiText.value, values.letterSpacing);
          const startX = rect.width / 2 - tw / 2;
          fillTextSpaced(ctx2d, uiText.value, startX, textY, values.letterSpacing);
          return;
        }
        const angleRad = ((values.textAngleDeg || 0) * Math.PI) / 180;
        ctx2d.save();
        ctx2d.translate(rect.width / 2, rect.height / 2);
        ctx2d.rotate(angleRad);
        ctx2d.textAlign = "left";
        ctx2d.font = `800 ${fontPx}px ${fontStack}`;
        const sample = uiText.value || "";
        const diag = Math.hypot(rect.width, rect.height);
        const stepY = fontPx * (values.textLineGap || 1.0);
        const wordW = Math.max(1, measureSpaced(ctx2d, sample, values.letterSpacing));
        const stepX = Math.max(1, wordW * (values.textHSpacing || 1.0));
        for (let row = 0, y = -diag; y <= diag; row++, y += stepY) {
          const dir = row % 2 === 0 ? 1 : -1;
          const s = values.textScrollPx % stepX;
          ctx2d.save();
          ctx2d.translate(dir * s, 0);
          const startX = -diag - stepX;
          for (let x = startX; x <= diag + stepX; x += stepX) {
            fillTextSpaced(ctx2d, sample, x, y, values.letterSpacing);
          }
          ctx2d.restore();
        }
        ctx2d.restore();
      }
      function drawTextLayerOutline(ctx2d) {
        const rect = canvas.getBoundingClientRect();
        const baseFontPx = Math.max(24, Math.min(160, rect.width * 0.12));
        const fontPx = baseFontPx * values.textScale;
        const fontStack =
          "'Commissioner', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, \"Helvetica Neue\", Arial";
        ctx2d.textBaseline = "middle";
        if (!values.textTiled) {
          ctx2d.textAlign = "left";
          ctx2d.font = `800 ${fontPx}px ${fontStack}`;
          const tw = measureSpaced(ctx2d, uiText.value, values.letterSpacing);
          const startX = rect.width / 2 - tw / 2;
          strokeTextSpaced(ctx2d, uiText.value, startX, textY, values.letterSpacing);
          return;
        }
        const angleRad = ((values.textAngleDeg || 0) * Math.PI) / 180;
        ctx2d.save();
        ctx2d.translate(rect.width / 2, rect.height / 2);
        ctx2d.rotate(angleRad);
        ctx2d.textAlign = "left";
        ctx2d.font = `800 ${fontPx}px ${fontStack}`;
        const sample = uiText.value || "";
        const diag = Math.hypot(rect.width, rect.height);
        const stepY = fontPx * (values.textLineGap || 1.0);
        const wordW = Math.max(1, measureSpaced(ctx2d, sample, values.letterSpacing));
        const stepX = Math.max(1, wordW * (values.textHSpacing || 1.0));
        for (let row = 0, y = -diag; y <= diag; row++, y += stepY) {
          const dir = row % 2 === 0 ? 1 : -1;
          const s = values.textScrollPx % stepX;
          ctx2d.save();
          ctx2d.translate(dir * s, 0);
          const startX = -diag - stepX;
          for (let x = startX; x <= diag + stepX; x += stepX) {
            strokeTextSpaced(ctx2d, sample, x, y, values.letterSpacing);
          }
          ctx2d.restore();
        }
        ctx2d.restore();
      }

      // Animation
      let last = performance.now();
      function tick(now) {
        const dt = Math.min(0.05, (now - last) / 1000);
        last = now;
        tSec += dt;
        if (idleSuppress > 0) idleSuppress = Math.max(0, idleSuppress - dt / Math.max(0.001, values.idleResumeSec));
        values.textScrollPx = (values.textScrollPx + values.textScrollSpeed * dt) % 1e9;
        values.dashPhase = (values.dashPhase + values.dashSpeed * dt) % 1e9;
        values.timeStep = dt;
        update();
        draw();
        requestAnimationFrame(tick);
      }

      const ro = new ResizeObserver(() => setCanvasSize());
      ro.observe(canvas);
      setCanvasSize();
      requestAnimationFrame(tick);
      runTests();
    </script>
  </body>
</html>
